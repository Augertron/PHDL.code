PHDL Language Reference Manual
==============================
Version 3.0.0 (draft)

:leveloffset: 1

include::PHDL_Language_Reference_Manual/Grammar.txt[]

include::PHDL_Language_Reference_Manual/Introduction.txt[]

include::PHDL_Language_Reference_Manual/Names.txt[]

include::PHDL_Language_Reference_Manual/Parameters.txt[]

include::PHDL_Language_Reference_Manual/Attributes.txt[]

include::PHDL_Language_Reference_Manual/Pins.txt[]

include::PHDL_Language_Reference_Manual/Slices.txt[]

// TODO:
//include::PHDL_Language_Reference_Manual/Ports.txt[]
//include::PHDL_Language_Reference_Manual/Devices.txt[]
//include::PHDL_Language_Reference_Manual/Designs.txt[]
//include::PHDL_Language_Reference_Manual/Packages.txt[]

:leveloffset: 0

Port
~~~~

A port is the part of a design that can be connected when instancing it in a larger design.

To the user of a design, a port on a design is just like a pin on a device.
A port behaves just like a net inside the design, but it's allowed to be connected externally.
A port has a single name.


##############################################################################
PARSER RULES
##############################################################################

------------------------------------------------------------------------------
PHDLBoardDesign ::= Import* ( Package | Device | Design )*
------------------------------------------------------------------------------

------------------------------------------------------------------------------
Import ::= "import" QualifiedNameOptWildCard ";"
------------------------------------------------------------------------------

Imports can be used at the beginning of a .phdl file in order to
import packages and their contents that have been previously defined
in other files, to be used in the current file.  

There is an optional wild card, that can be used to import the
contents of an entire package.

The devices, designs, and sub-designs must be referenced according to
their specified package name, see QualifiedNameOptWildCard rule below.

------------------------------------------------------------------------------
Package ::= "package" PackageName "{" Import* ( Device | Design )* "}"
------------------------------------------------------------------------------

Packages can be used to organize groups of device definitions and
sub-design declarations into a package for later use. Packages allow
cross-references across file boundaries and allow source code to be
split up into separate files.

Currently, packages cannot be nested and the only objects that may be
declared inside of a package are devices, designs, and sub-designs.

Packages provide a framework for qualified namespaces. See section
entitled: "Qualified Namespaces" for information on how this should be
implemented.

While there are some obvious ways to implement importing packages, the
language makes no stipulation on how it should be done.  In one
method, all files to be compiled must be specified together on the
compile line so that the compiler will have processed needed package
definitions before they are imported by later files.  In another
method, some form of work directory could be used to support separate
and independent compilation and importing.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
DEVICES
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
Device ::= "device" DeviceName "{" DeviceElement* "}"
------------------------------------------------------------------------------

The Device rule is used to define the interface between a "PHDL device
instantiation" and the footprint (or package) definition within your
chosen layout tool. Every type of device used in the design must have
a device definition which links it to the footprint that will be used
when designing the layout.

Devices can contain any combination of DeviceElements between the
curly braces, but there are some required elements that every device
definition must include, see DeviceElement rule.


------------------------------------------------------------------------------
DeviceElement ::= AttrDeclaration | PinDeclaration | InfoStatement
------------------------------------------------------------------------------

A Device can contain any combination of attribute declarations, pin
declarations, or info statements, but there are 3 required attribute
declarations which every device definition must include:

1. REFPREFIX: Used by the compiler when automatically generating
   unique reference designators for device instantiations (done if
   the reference designator is not explicitly set using a REFDES
   attribute).

2. FOOTPRINT: Identifies the footprint (or package) used by the layout
   tool for this device.

3. LIBRARY: Identifies  the library in the
   layout tool that contains the footprint mentioned above. 
  
By convention, these attributes are upper-case, but that is not
required and they are not case sensitive.

------------------------------------------------------------------------------
AttrDeclaration ::= "attr" AttrName "=" STRING ";"
------------------------------------------------------------------------------

Attributes can be used to contain any type of data desired with
reference to a specific device.

Attribute declarations are allowed within both device definitions and
device instantiations as well as in net declarations.

There has been some discussion about whether attribute names and
values should be case sensitive.  They are not. The current PHDL
tools created at BYU give a warning and otherwise treat them as case insensitive.

There are some optional special attributes:

  REFDES: If the REFDES attribute is defined as anything other than an
   	  empty string, the compiler will use the value of REFDES as
   	  the device instantiation's unique reference designator,
   	  rather than generating one using REFPREFIX.

  PINCOUNT: The value of the PINCOUNT attribute must be an
            Integer. If the number of pins declared in the device
            definition doesn't match the value of PINCOUNT, the
            compiler should throw an error.

 Other common uses for attributes:

   VALUE: used to define resistance, capacitance, inductance

   COST: can be used for bill of materials and part procurement

   MFGR: can be used for bill of materials and part procurement

   PARTNUMBER: can be used for bill of materials and part procurement

Essentially, attributes can be used to store any data necessary for
back-end tools to use.

------------------------------------------------------------------------------
PinDeclaration ::= PinType [Vector] PinName "=" "{" PhysicalPinName [( "," PhysicalPinName )*] "}" ";"
------------------------------------------------------------------------------

The PinDeclaration rule is used to declare pins and to map logical
PHDL PinNames to the PhysicalPinName from the footprint (or package)
definition in your chosen layout tool.

PinType is used to specify a specific pin type which can be used by an
electric rule checker once the entire design has been elaborated. See
the PinType rule.

A Vector of pins, or multi-bit pins with the same name can be declared
using the Vector rule. However these pins should be interpreted and
treated as individual pins aside from the fact that they share a name
and can be referenced together, either all at once or by index. See
section on Vectors and Ranges below.

A PhysicalPinName is an identifier that can be used to reference the
unique pin or pad in your layout editor footprint (or package)
definition.

If the vector option is used, the vector indices on the left side of
the equals sign (reading from left to right), are mapped to the
PhysicalPinNames on the right side of the equals sign (also reading
from left to right).  The number of pins enumerated on the right side
of the equals sign should always equal the number of PhysicalPinNames
on the left side.

For more information on how PinDeclarations should be interpreted, see
the section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments".

------------------------------------------------------------------------------
PinType ::= "pin"
           | "inpin"
           | "outpin"
           | "iopin"
           | "pwrpin"
           | "suppin"
           | "ocpin"
           | "oepin"
           | "tripin"
           | "passpin"
           | "ncpin"
------------------------------------------------------------------------------

The PinType rule is a collection of keywords that can be used to
define pins.

The keywords stand for the following pin types:
   pin - Unspecified Pin
   inpin - Input Pin
   outpin - Output Pin
   iopin - IO Pin
   pwrpin - Power Pin
   suppin - Supply Pin
   ocpin - Open Collector Pin
   oepin - Open Emitter Pin
   tripin - Tri-State Pin
   passpin - Passive Pin
   ncpin - No Connection

These pintypes could be used by an electric rule checker to find faulty
connections within a net.

------------------------------------------------------------------------------
InfoStatement ::= "info" "{" STRING "}"
------------------------------------------------------------------------------

The InfoStatement rule can be used to make comments (such as placement
needs) about a specific device or connection which can then be relayed
to the layout designer.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Designs
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
Design ::=      ( "design" DesignName "{" DesignElement* "}" )
             |  ( "subdesign" SubDesignName "{" SubDesignElement+ "}" )
------------------------------------------------------------------------------

The Design rule encompasses both design declarations and sub-design
declarations.

A Design encompasses all the connectivity of a single PCB. No
connectivity extends outside the scope of the Design block. In other
words the Design is the top level of a PHDL design.

Designs can contain any combination of DesignElements.

Sub-Designs were specifically created to enable the use of hierarchy
and are virtually identical to designs with the added ability to
declare ports, thus supporting hierarchy.

Sub-Designs are invalid if they do not contain at least one device or
sub-design instantiation. 

------------------------------------------------------------------------------
DesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement
------------------------------------------------------------------------------

Designs can contain any combination of nets, instances, info
statements, and connection assignments.

------------------------------------------------------------------------------
SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement | PortDeclaration
------------------------------------------------------------------------------

Sub-designs can contain everything that a design can, plus
PortDeclarations.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Connections
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Both nets and ports are Connections.

------------------------------------------------------------------------------
NetDeclaration ::= "net" [Vector] NetName ( "," NetName )* ( "{" NetElement* "}" ) | ";"
------------------------------------------------------------------------------

The NetDeclaration rule is used to declare any number of nets of the
same width.

A Vector can be used to declare multi-bit nets, see Vector and Range
rules below.

NetElements defined in a NetDeclaration will be applied to all nets
declared in the declaration.

------------------------------------------------------------------------------
NetElement ::= AttrDeclaration | InfoStatement
------------------------------------------------------------------------------

NetDeclarations can contain attribute declarations or info statements.

------------------------------------------------------------------------------
PortDeclaration ::= "port" [Vector] PortName ( "," PortName )* ( "{" InfoStatement* "}" ) | ";"
------------------------------------------------------------------------------

The PortDeclaration rule is the same as a NetDeclaration, except that
attributes are not allowed to be defined for Ports.

PortDeclarations are only allowed within sub-designs and are used with
hierarchy in order to connect internal nets or pins to the outside
world.

Ports can also be used as nets/connections to establish connectivity
between pins within a sub-design. In the case where a port is declared
as "open", this connectivity within the sub-design must be preserved, 
even though there is no connection made outside the sub-design itself. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Instances
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
Instance ::= ( "inst" [Array] InstName "of" QualifiedDeviceName "{" InstanceElement* "}" ) 
        | ( "subinst" [Array] SubInstName "of" QualifiedSubDesignName [STRING] "{" SubInstElement* "}" )
------------------------------------------------------------------------------

The Instance rule is used to instantiate devices or sub-designs.

Multiple devices can be instanced at once using the Array rule
below. For more information on how Arrays should be interpreted, see
the section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments".

The optional STRING field in sub-instance declarations is a REFPREFIX
value that will be prepended to the reference designators of all
devices instantiated within the sub-design instantiation. Another
option is to declare an attribute in the sub-instance called
REFPREFIX. The value of this attribute will then be prepended to all
reference designators of all instances, sub-instances, and connections
within the sub-instance. In either case the "/" character will be used
as a delimiter between the REFPREFIX and the original reference
designator.

Instancing a device in PHDL is equivalent to dragging a device from a
library in a conventional PCB design tool onto the schematic
page. Instancing a device defines two relationships: (1) which device
the instance inherits all pins from, and (2) defines how all of the
pins are to be connected to the rest of the design.

A similar concept applies when instantiating a sub-design except that
it is equivalent to adding a predefined hierarchical block to a design
and connecting its ports to nets in the current design.

------------------------------------------------------------------------------
QualifiedDeviceName ::= [PackageName "."] DeviceName              
------------------------------------------------------------------------------

The QualifiedDeviceName rule allows for devices to be referenced by
package, if the specified device is contained within a package and has
not already been imported using the Import rule.

PackageName is thus the name of the package containing the specified
device.

See section entitled: "Qualified Namespaces" for information.

------------------------------------------------------------------------------
InstanceElement ::= AttrDeclaration | RefAttr | PinAssign | InfoStatement
------------------------------------------------------------------------------

Instances can have any combination of attribute declarations,
attribute references, pin assignments, and info statements. However
each device instance is required to have a pin assignment for every
pin declared within the referenced device definition.

------------------------------------------------------------------------------
QualifiedSubDesignName ::= [PackageName "."] SubDesignName
------------------------------------------------------------------------------

The QualifiedSubDeviceName rule allows for devices to be referenced by
package, if the specified sub-design is contained within a package and
has not already been imported using the Import rule.

PackageName is thus the name of the package containing the specified
sub-design.

See section entitled: "Qualified Namespaces" for information.
 
------------------------------------------------------------------------------
SubInstElement ::= AttrDeclaration | SubAttrRef | PortAssign | InfoStatement
------------------------------------------------------------------------------

SubInstances can have any combination of attribute declarations,
sub-attribute references, port assignments, and info
statements. However each sub-design instance is required to have a
port assignment for every port declared within the referenced
sub-design.

There is an optional special attribute which can be declared in the
sub-instance called REFPREFIX.  If this attribute is declared then
value of this attribute will be prepended to all reference designators
of all instances, sub-instances, and connections within the
sub-instance. The "/" character will be used as a delimiter between
the REFPREFIX and the original reference designator.
 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Ref Attributes
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
------------------------------------------------------------------------------
RefAttr ::= [Qualifier] AttrName "=" STRING ";"
------------------------------------------------------------------------------

The RefAttr rule is used to modify an existing attribute when
instantiating a device.

The old value of the attribute declared within the device definition
should be overwritten with the new STRING value.

The optional Qualifier rule should only be allowed in the case where
an array of devices are being instanced at once.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Pin Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
       
------------------------------------------------------------------------------
PinAssign ::= ( "combine" "(" PinReference ")" "=" Concatenation ";" )
                | ( PinReference "=" Concatenation ";" )
------------------------------------------------------------------------------

The PinAssign rule is used to assign pins within a device
instantiation to existing connections (nets or ports) or to assign
them as "open".

There must be a pin assignment assigning every pin declared in the
device definition referenced by the device instantiation.

PinReferences allow slices, which allow a user to assign multiple bits
to a net at once.

The order of assignment in PHDL always takes place from left-to-right
in the order the arrayed object was declared. The following pin
assignment is given as an example:
 
 //Device Library (required attributes omitted)
 device hdr2 {
   pin[1:0] p = {p1, p2};
 }
 
 design top {
   net[3:2] bus;
   inst myHdr of hdr2 {
       p = bus;
   }
 }

In the above case, the pin p[1] is assigned to the net bus[3] and the
pin p[0] is assigned to the net bus[2].

The number of pins referenced on
the left of the assignment should match the number of connections
referenced by the concatenation on the right side.

Within an arrayed device instance, the optional combine notation can
be used. The combine notation should be illegal in the case where a
single device is being instanced.  (See section on combine notation
below.)
 
------------------------------------------------------------------------------
PinReference ::= [Qualifier] PinName [Slices]
------------------------------------------------------------------------------

The PinReference rule is a reference to a set of pins that are to be
assigned connection.

The optional Qualifier rule should only be allowed when an array of
devices are being instanced at once.

The optional Slices rule allows for referencing of specific bits
within a multi-bit vector of pins. This can either be done with a
Range or by comma separated list of indices.

Assignments using Slices should always be done reading from
left-to-right. (See Slices rule).

If the Slices rule is not used on a multi-bit vector of pins, the
PinReference refers to the entire vector of pins and they should be
assigned from left-to-right in the order they were declared in the
device definition.
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Combine Notation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Combine notation takes an array of pins that are common across an
instance array and lines them up into a larger array. The order of
assignment in PHDL always takes place from left-to-right in the order
the arrayed object was declared. The example below shows this:
 
device memory_1024x8 {
  //Attributes omitted
  pin[7:0] data;                   //Our memory has an 8 bit wide data pin array
  //...
}

design myDesign {
  net[15:0] data_bus;              //We have a 16 bit data bus

  inst(1:0) memory_array of memory_1024x8 {
    combine(data) = data_bus;   //Using combine we can line up the two 8bit pin arrays
                                //from both memory devices into a 16bit pin array and 
                                //then connect them to a 16bit bus.
                                //this(1).data[7:0] is now assigned to data_bus[15:8] and
                                //this(0).data[7:0] is now assigned to data_bus[7:0]
  }
}

If the combine notation is not used the pins are connected in
parallel. For example the combine statement above could have been
replaced with the following:

  data = data_bus;  

and the data_bus net declaration replaced with:
 
  net[7:0] data_bus;

Thus, the data_bus would necessarily be only 8 bits wide and both 8
bit data arrays would be connected to it. (this(1).data[7:0] would be
assigned to data_bus[7:0] and this(0).data[7:0] would also be assigned
to data_bus[7:0])

The pin width on the left of the assignment should match the pin width
on the right side.

As with everything else in PHDL if no indices are specified then the
assignment always takes place in the order the arrayed or vectored
object was originally declared from left-to-right.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Sub Attribute References
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
SubAttrRef ::= [Qualifier] [RefTail] InstName "." AttrName "=" STRING ";"
------------------------------------------------------------------------------

The SubAttrRef rule can be used within a sub-instance to reach down
into the hierarchy and change an attribute value on an instance. This
allows the user to define a hierarchical block, instantiate it many
times throughout their design, and then customize the individual
sub-instances. (For example: A design may contain multiple audio ports
whose circuitry is identical with the exception of an RC filter's
resistance and capacitance values).

The optional RefTail rule can be used to reach down arbitrarily deep
from sub-instance to sub-instance to reach the instance who's
attribute the user desires to change.

The optional Qualifier rule should only be allowed within an array of
sub-design instances.

See the Qualifier rule below for more detail on what it allows.

------------------------------------------------------------------------------
RefTail ::= SubInstName [Indices] "." [RefTail]
------------------------------------------------------------------------------

The RefTail rule allows the user to reach arbitrarily deep into the
hierarchy from sub-instance to sub-instance.

The optional Indices rule allows the user to reference a set of
arrayed sub-instances somewhere down the hierarchy using either a
range or a comma separated list of indices.

For more information on how Indices should be interpreted, see the
section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments" as well as
the Indices and Range rules.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Port Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
------------------------------------------------------------------------------
PortAssign ::= ( "combine" "(" PortReference ")" "=" Concatenation ";" )
        | ( PortReference "=" Concatenation ";" )
------------------------------------------------------------------------------

The PortAssign rule should be interpreted exactly as the PinAssign
rule except that it is used to assign ports in sub-design instances to
connections in the current design rather than to assign pins. All the
same specifications that apply to pin assignments should apply to port
assignments.

Within an arrayed sub-design instance, the optional combine notation
can be used. The combine notation should be illegal in the case where
a single sub-design is being instanced.

(See section on combine notation above.)

------------------------------------------------------------------------------
PortReference ::= [Qualifier] PortName [Slices]
------------------------------------------------------------------------------

A PortReference should be interpreted to be exactly like a
PinReference except that it references PortDeclarations in the
sub-design declaration being instanced, rather than PinDeclartations
in the associated device definition.

The optional Qualifier rule should only be allowed within an array of
sub-design instances.

See the Qualifier rule below for more detail on what it allows.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Connection Assignments and Concatenation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
ConnectionAssign ::= ConnectionName [Slices] "=" Concatenation ";"
------------------------------------------------------------------------------

The ConnectionAssign rule allows for connectivity to be established
between two connections such as between two nets or between a net and
a port.

ConnectionName is an identifier used to reference the port or net
being assigned.

The scope of allowable ConnectionNames for a given ConnectionAssign
should only include the connections declared within the current design
or sub-design.

The optional Slices rule allows for referencing of specific bits
within a multi-bit vector connection. This can either be done with a
Range or by comma separated list of indices. See the Slices rule for
more details.

When slices are used, assignment should always be done reading the
indices on the left side of the equals sign (from left-to-right) and
connecting them one by one to the connections on the right side of the
equals sign (also reading from left-to-right).

When slices are not used for a vector connection, it is assumed that
the entire vector is being referenced (again reading the indices from
left-to-right how the connection was declared).

If the number of referenced connections on the left side of the equals
sign does not equal the number of connections referenced by the
concatenation, The compiler should throw an error. (Count each
individual indice as a connection).

For more information on how assignments should be interpreted, see the
section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments" as well as
the Indices and Range rules.

------------------------------------------------------------------------------
Concatenation ::=       
    ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
    ( ConnectionRef ( "&" ConnectionRef )* ) |
    ( "<" ConnectionRef ">" ) |
    ( ConnectionRef "*" ) |
    ( "open" )
------------------------------------------------------------------------------

A Concatenation can be used to concatenate or line up several
connections into a large vector and then assign them to another vector
of connections or pins.

A concatenation can take a number of forms:

 - A comma-separated list of ConnectionRefs contained within curly
   brackets, should be read from left-to-right as individual one-bit
   connections and lined up into a large multi-bit vector of
   connections.

 - A list separated by the '&' character should be treated exactly
   like the comma-separated list above.

 - A single one-bit (non-vector) connection enclosed in angle brackets
   '<' '>' should be replicated or branched into however many
   connections are needed to match the left hand side of the
   assignment.  In other-words, every pin or connection on the left
   hand side of the assignment should be connected to this singular
   net in parallel. We call this replication.

 - A single one-bit (non-vector) connection followed by the '*' symbol
   should be treated the same as the connection enclosed in angle
   brackets above. We call this replication.

 - A connection can also be defined as "open". This would have no
   affect if performing a connection assign, but if performing a pin
   assignment or port assignment it signifies that nothing should be
   connected to the pin or port.  If this occurs within a PortAssign,
   it is important to make sure that if the port was used as a
   connection between nets or pins down-within the sub-design that
   this connection is preserved when the design is elaborated.

Replication should only be allowed for single-bit connections. However
an index of a vectored or multi-bit connection can be specified using
the slices rule as shown here:

  net[7:0] low_byte;
  net[15:0] data;

  //sign-extend the low_byte into the upper data bits.
  data[15:8] = <low_byte[7]>;
  data[7:0] = low_byte;

------------------------------------------------------------------------------
ConnectionRef ::= ConnectionName [Slices]
------------------------------------------------------------------------------

A ConnectionRef is a reference to a ConnectionName with the option of
using the Slices rule to reference specific bits of a multi-bit vector
connection.

For more information on how Slices should be interpreted, see the
section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments" as well as
the Slices and Range rules.

As always indices should be read from left-to-right.
 
------------------------------------------------------------------------------
ConnectionName ::= NetName | PortName
------------------------------------------------------------------------------

ConnectionName is a substitute for either a NetName or a PortName.

PortNames should only be allowed however, if inside a sub-design.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Arrays, Indices, Vectors, and Slices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
Array ::= "(" Range ")"
------------------------------------------------------------------------------

Arrays can be used to instantiate multiple devices or sub-designs with
one instance declaration. This allows the user to instance an
arbitrary number of similar devices or sub-designs and connect their
pins/ports as a unit rather than one by one.

The Range for an array is enclosed in round braces to differentiate it
from the Vector rule.

------------------------------------------------------------------------------
Indices ::= "(" (   Range  | ( Integer ( "," Integer )* )  ) ")"
------------------------------------------------------------------------------

The Indices rule can be used to reference a set of instanced devices
or sub-designs from an array, by index.

This can either be done using a Range or with a comma-separated list
of indices. In both cases, the indices referenced must have been
originally declared in the corresponding arrayed instance declaration.

The Indices rule is enclosed in round braces in-order to match Arrayed
device or sub-design instantiations and to differentiate it from
Slices.

Indices should only be allowed to be used when referencing an Array of
device or sub-design instances.
 
------------------------------------------------------------------------------
Vector ::= "[" Range "]"
------------------------------------------------------------------------------

Vectors can be used to declare multi-bit pins, nets, or ports. This
allows the user to declare and assign an arbitrary number of
connections or pins with the same name and all at once, rather than
individually. (For example the user could define a 16bit data pin for
a memory chip, and then connect it to a 16bit bus with only one line
of code to define the pin and one line of code to connect it when the
device is instantiated).

The Range for a vector is enclosed in square brackets to differentiate
it from the Array rule.
 
------------------------------------------------------------------------------
Slices ::= "[" (   Range  | ( Integer ( "," Integer )* )  ) "]"
------------------------------------------------------------------------------

The Slices rule can be used to reference a set of pins or connections
declared as part of a vector, by index.

This can either be done using a Range or with a comma-separated list
of indices. In both cases, the indices referenced must have been
originally declared in the corresponding vectored pin/connection
declaration.

The Slices rule is enclosed in square brackets in-order to match
Vector pin/connection declarations and to differentiate it from the
Indices rule.

Slices should only be allowed to be used when referencing a Vector or
multi-bit pin or connection (port/net).

------------------------------------------------------------------------------
Range ::= Integer ":" Integer
------------------------------------------------------------------------------

Ranges can be used to specify an ordered range of indices. The ':'
character can be likened to the "downto" or "to" keywords in VHDL.
Both the Integers are included in the range.  For example the range:
"7:0" specifies 8 individual indices from left-to-right 7 down to 0.

Ordering the other direction is also legal: "0:7" specifies 8
individual indices from left-to-right 0 up to 7.

Another way to think of it is that the Range 1:3 means reference 1,2,3
in that order and the Range 3:0 means reference 3,2,1,0 in that order.
 
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, PinDeclarations, and Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
There are a few rules that must be followed when interpreting these
rules in-order to ensure this:

 1.  When interpreting arrayed device or sub-design instance
 declarations each instance in the array must be interpreted and
 treated as its own unique individual instance.  The only difference
 between how this instance and a non-arrayed instance should be
 handled is that it shares a name with the other instances in the
 array and can be referenced individually or together with the other
 instances in the array.  A unique identifier for this instance can be
 generated by concatenating the name to its unique index.

 2.  When interpreting multi-bit or vectored connections/pins each
 connection/pin in the vector must be interpreted and treated as its
 own unique individual connection/pin.  The only difference between
 this connection/pin and a non vectored connection/pin is that it 
 shares a name with the other connections/pins in the vector and can
 be referenced individually or together with the other
 connections/pins in the vector.  As with an arrayed device, a unique
 identifier for this connection/pin can be created by concatenating
 the name to its unique index.

 3.  Arrays, Indices, Vectors, Slices, Ranges, and Concatenations must
 be interpreted as a string of individual connections/pins/references
 lined up from left-to-right.

 4.  Lastly when interpreting assignments and pin declarations the
 left-most index referenced on the left hand side of the equal sign is
 to be assigned to the left-most index on the right hand side of the
 equal sign (or the left-most PhysicalPinName on the right hand side
 in the case of pin declarations). The second-left-most index
 referenced on the left hand side of the assignment should be assigned
 to the second-left-most index on the right hand side of the equals,
 etc...

If indices are not explicitly stated in an assignment referencing
arrayed or vectored objects it is assumed that the entire array or
vector is being referenced. In the case of arrayed instances each
instance will be treated individually and the assignment will be
applied to each instance. In the case of vectored pins, ports, or
connections the assignment will occur in the order they were
originally declared from left to right.

The number of individual references on both sides of the assignment
should always be equal.
 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Qualifier and Qualified Names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

------------------------------------------------------------------------------
Qualifier ::= "this" [Indices] "."
------------------------------------------------------------------------------

The Qualifier rule is used to specify a specific subset of an arrayed
set of either device or sub-design instances.

The optional Indices rule is what allows specific instances within the
array to be referenced.

The Qualifier rule should only be allowed when wanting to reference a
specific set of either device or sub-design instances within an
arrayed instance declaration. It specifies a specific or a set of
specific instances within the array to be referenced, allowing the
user to make a pin/port assignment or attribute reference specific to
only certain instances with in the array, referenced by index. This
allows for many devices/sub-designs of the same type to be instanced
at once while connecting them differently, or in similar manner,
 as needed. The combine notation, allows for them to be connected 
together as a group with a single line of code, if so desired as well.

For example:

device resistor {
    attr REFPREFIX = "R";
    attr FOOTPRINT = "R0603";
    attr LIBRARY = "rcl-smd";
    attr VALUE = "1k";
    pin a = {1};
    pin b = {2};
}
 
design top {
 
    net vcc, gnd, ref;
    
    // a simple voltage divider with two resistors between the three above nets
    inst(1:0) my_res of resistor {
        this(1).VALUE = "2k";
        this(1).a = vcc;
        b = ref;
        this(0).a = gnd;
    }
    
    // ... more of the design down here
}

In the above example, the 'a' pin on the resister my_res(1) is assigned
to vcc, while the 'a' pin on my_res(0) is assigned to gnd. Both 'b' pins
are assigned to the ref net and the VALUE attribute of my_res(1) is
set to "2k", while the VALUE attribute of my_res(0) remains the
previously defined value of "1k".

For more information on how Indices should be interpreted, see the
section entitled: "Interpreting Arrays, Indices, Vectors, Slices,
Ranges, Concatenations, PinDeclarations, and Assignments" as well as
the Indices and Range rules.

------------------------------------------------------------------------------
QualifiedNameOptWildCard ::= PackageName "." ( "*" | ( DeviceName | DesignName | SubDesignName ) )
------------------------------------------------------------------------------

The QualifiedNameOptWildCard rule allows for imports by package.

PackageName is a reference to a predefined package with devices,
designs, or sub-designs that the user desires to use within the
current design.

If the '*' character is used, all devices, designs, and sub-designs
contained in the package should be imported. If this is not the case
only the specified device, design, or sub-design should be imported.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Qualified Namespaces
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Packages provide a framework for qualified namespaces. This means that
each named object within the package is prefixed with the package name
using standard dot-notation to separate the two names.

If a package called "foo" contains a device called "fum", then the
device can be referred to in a design as "foo.fum".

This should be allowed any time a sub-design or device definition is
instantiated within a design, even if the package containing the
definition has not been previously imported. See the
QualifiedDeviceName and the QualifiedSubDesignName rules above.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Element Names/Identifiers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    DeviceName ::= PhdlID
    PinName ::= PhdlID
    PhysicalPinName ::= PhdlID
    NetName ::= PhdlID
    PortName ::= PhdlID
    PackageName:: = Identifier
    AttrName ::= Identifier
    DesignName ::= Identifier
    SubDesignName ::= Identifier
    InstName ::= Identifier
    SubInstName ::= Identifier


------------------------------------------------------------------------------
PhdlID ::= Integer | Identifier | PINUM
------------------------------------------------------------------------------

The PhdlID rule is currently used as a combination of the Integer,
Identifier, and PINNUM rules thus allowing the identifier to be any of
these.

##############################################################################
LEXICAL ELEMENTS
##############################################################################

PHDL files must always consist of valid UTF-8 encoded Unicode
text. This input is then normalized and split into lexical elements
used in the rest of the grammar. Each element is described in detail
below.

------------------------------------------------------------------------------
Identifier = (\p{ID_Continue} - (\p{Mn} - \p{Mc})) \p{ID_Continue}*
------------------------------------------------------------------------------

All identifiers are like standard Unicode identifiers, but can start with any
of the full set of identifier codepoints, except for the combining marks which
are still only allowed after the first codepoint.

------------------------------------------------------------------------------
Integer = [0-9]+
------------------------------------------------------------------------------

All integers are in decimal. Leading zeros are explicitly allowed.


------------------------------------------------------------------------------
PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+
------------------------------------------------------------------------------


------------------------------------------------------------------------------
STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
        "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"
------------------------------------------------------------------------------


------------------------------------------------------------------------------
Line_Ending =
    | \x0A       // LINE FEED (LF)
    | \x0B       // LINE TABULATION
    | \x0C       // FORM FEED (FF)
    | \x0D       // CARRIAGE RETURN (CR)
    | \x85       // NEXT LINE (NEL)
    | \x2028     // LINE SEPARATOR
    | \x2029     // PARAGRAPH SEPARATOR
------------------------------------------------------------------------------

------------------------------------------------------------------------------
Single_Line_Comment = "//" (!Line_Ending)* Line_Ending
------------------------------------------------------------------------------

------------------------------------------------------------------------------
Multi_Line_Comment = "/*" !("*/") "*/"
------------------------------------------------------------------------------

Neither kind of comment can be nested.

------------------------------------------------------------------------------
Whitespace = \p{Pattern_White_Space}+
------------------------------------------------------------------------------

All whitespace characters between (but not part of) individual lexical
elements are ignored. Whitespace consists of one or more Unicode
characters in a row with the "Pattern_White_Space" property.
