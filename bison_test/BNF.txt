Import ::= "import" QualifiedNameWithWildCard ";"
// This is how you include packages of devices and subdesigns that
// were previously defined in other files.
 
 Package ::= "package" ID "{" Import* ( Device | Design )* "}"
   // Packages can contain imports and device and design declarations

// Currently, when we include packages, and those packages have imports in them, do we inherit the imports? 
// It would be best for encapsulation if we did not.

 Attr ::= "attr" ID "=" STRING ";"
   // The ID and value associated with an attribute is strictly
   // user-defined.  However, there are some required attributes
   // including: REFPREFIX, FOOTPRINT, and LIBRARY.  By convention,
   // they are upper case but that is not required and they are not
   // case sensitive.  There has been some discussion about whether
   // VALUE and Value should be the same or different attributes and
   // whether the user should be warned.  The current tools give a
   // warning and then combine them.

// Everything else is case-sensitive. Why are we treating attribute names as a special case?

// Also, let's talk about required attributes.

// REFPREFIX doesn't necessarily need to be required. If not given, it could just default to something sensible, like "U" (giving, U1, U2, U3
// -- very common for the majority of IC devices), or even just "" (giving simple numbers, 1, 2, 3, 4 -- maybe not what you WANT, but by default it's as good as anything else). We can have specific semantic checks that check for refprefixes that most people will want, but it doesn't need to be a core part of the language.
// 
// FOOTPRINT doesn't necessarily need to be required. While most of the time you'd want to have a footprint defined, it could also just be defined later in the PCB tool. Obviously we'll want a semantic check available to identify missing footprints accidentally left out in most designs, but I'm not sure we should force this in the language itself.
// 
// LIBRARY is required, but so far we've just left it blank in most designs. Why is this required? If it is useful, we can make a semantic check available to look for it, but there isn't a lot of reason the core language needs to enforce this, right?
// 

 Pin ::= PinType [Vector] PhdlID "=" "{" PhdlID [( "," PhdlID )*] "}" ";"
   // Pins can be single bits wide or can be vectors of multiple bits.
   // The values in { } are the physical pin names presumably taken
   // from the footprint in the library..
 
 PinType ::= "pin"
                 | "inpin"
                 | "outpin"
                 | "iopin"
                 | "pwrpin"
                 | "suppin"
                 | "ocpin"
                 | "oepin"
                 | "tripin"
                 | "passpin"
                 | "ncpin"
   // The purpose of the pin directions is to allow for ERC where it
   // checks for multiple outpins on a net, for example.  To date, all
   // designs have just used "pin" but an ERC has been implemented in
   // the 2.1 tools.

// I propose to drop directed pins in our first PHDL language spec. It isn't widely used and I think it's trying to enforce too much in the core language. We aren't using this on any real boards yet, I don't think, and there are a number of problems with the pin types as defined here.

// A better (future!) idea would probably be the idea of generic pin attributes that can be checked by optional semantic check passes/tools.

 Info ::= "info" "{" STRING "}"
   // The purpose of info is to allow the designer to attach
   // information to specific devices, nets, ports, designs/subdesigns,
   // and instances/subinstances.  This gets propagated to the output
   // files and can be used to communicate with the layout engineer.

// This feature overlaps with the purpose of comments and additionally assumes that that the layout engineer can't just read the PHDL. Should we keep this?

 Design ::= 	( "design" ID "{" DesignElement* "}" ) 
 	  	|  ( "subdesign" ID "{" SubDesignElement* "}" )
   // This rule encompasses both design declarations and subdesign 
 declarations
 
 DesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info  
   // Designs can contain nets, instances, info statements, and
   // net-to-net assignments.
 
 SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info | PortDeclaration
   // Subdesigns can contain everything designs can plus port declarations.
 
 NetDeclaration ::= "net" [Vector] ConnectionName ( "," ConnectionName )* 
                 ( "{" NetElement* "}" ) | ";"
 NetElement ::= Attr | Info
   // Net declarations can be multiple bits wide.  Muliple names in one
   // declaration are all of that type.  If desired, attributes or info
   // can be attached to the nets as in:
   // net a, b, c { info { "These adsfgkjadsfljkas df" }}

// Oh, we already have net attributes! Is anyone using these? How are they exposed currently in the output? Are there any semantic checks currently? I think they are a good idea, but like device attributes, let's be careful about what we called required and how we use these.

 PortDeclaration ::= "port" [Vector] ConnectionName ( "," ConnectionName )* ( "{"
                         Info* "}" ) | ";"
   // These are similar to net declarations but bring out signals for 
 subdesigns

// Ports can have attributes too? Am I reading that right?

 RefAttr ::= [Qualifier] ID "=" STRING ";"
   // This is when you refer to and modify an existing attribute on a
   // device.  That is, you can over-ride the attribute value
   // specifiecd when the device was declared.
   // In constrast, the Attr rule allows you to create a new attribute
   // (either in a device decl or when instancing).

// What if a device has a pin named "A1" and an attribute named "A1"? Is this disambiguated based on what is assigned (pin vs. net)? Or am I reading this wrong?

 Concatenation ::=       ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
                         ( ConnectionRef ( "&" ConnectionRef )* ) |
                         ( "<" ConnectionRef ">" ) |
                         ( ConnectionRef "*" ) |
                         ( "open" )
   // A concatenation can take a number of forms:
   // {a, b, c} or a & b & c which are similar to Verilog's - the signals are lined up left-to-right to make a bus
   // <a> or a* which make as many copies of the signal as needed for the LHS of the assignment statement
   // "open" means that the pin or port is purposely being left 
 unconnected

// Why are we supporting both {} and & concatenation? Is there a difference?

// Why are we supporting both <> and * expansion? Is there a difference?
Also, I thought '*' was supposed to be an available character for pins, since '*' is often used, like #, _n, and _b to indicate low-assertion.

 QualifiedNameWithWildCard ::= QualifiedName ["." "*"]
   // These are used when importing packages

// What's the difference between:

  // import foo
// and
  // import foo.*

// Is it that one brings all the subdesigns and devices into the current package scope?

// Does the foo.* method inherit previous imports done with foo.*? What about ones done with just foo?

 ID: ('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*
 INT: ('0'..'9') | (('1'..'9') ('0'..'9')+ )
 PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+

// I thought PINNUM originally included '*'. Am I mistaken, or did we take that out?

// Also, we should consider supporting Unicode in the future, but maybe not this iterations.

 STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
         "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"

// Some of these escapes are rather obscure and arbitrary (e.g. why do we have \b but not \v?) What is \u all about? We don't support Unicode currently (although we ought to in a future version, and I will propose that then). If our charset is ASCII or Latin1, we need at least an \x escape.

