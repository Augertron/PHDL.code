PHDL Language Grammar Specification
===================================
Version 3.0.0, Unreleased

The following specification includes two main parts:
	1. The Grammar or Allowable Syntax
	2. Explanations of each of the specified rules detailing the 
		significance of each grammar rule and its parts and what each 
		token/rule represents.


Parser Rules
------------

PHDLDesign ::= Import* ( Package | Device | Design )*
 -----
 PHDLDesign is the head rule for the source code model generated by the
  parser. 
 A PHDLDesign may contain any combination of package declarations, device
  definitions or design declarations, in any order, but the compiler must 
  require declare-before-use. 
 All imports must come before any package, device, or design declarations/
  definitions.

Import ::= "import" QualifiedNameOptWildCard ";"
 -----
 Imports can be used at the beginning of a .phdl file in order to import
  packages, devices, sub-designs that have been previously defined
  in other files, to be used in the current file.
 There is an optional wild card, that can be used to import the contents of
  an entire package. 
 The devices, designs, and sub-designs must be referenced according to their
  specified package name, see QualifiedNameOptWildCard rule below.

Package ::= "package" PackageName "{" Import* ( Device | Design )* "}"
 -----
 Packages can be used to organized groups of device definitions and sub-design
  declarations into a package for later use.
 PackageName is an identifier used to refer to the package from other rules in the 
  grammar, see Identifier section below.
 A package contains the device definitions and design declarations contained within
  the curly braces. Any combination or order of device definitions and design 
  declarations are allowed.
 Imports can also be used to import definitions or declarations from external files 
  to be included within the current package, but imports must come before any other 
  definitions/declarations.

//////////////
// Devices  //
//////////////

Device ::= "device" DeviceName "{" DeviceElement* "}"
 -----
 The Device rule is used to define the interface between a "PHDL device instantiation"
  and the footprint (or package) definition within your chosen layout tool. 
 DeviceName is an identifier used to refer to the device definition from other rules 
  in the grammar, see Identifier section below.
 Devices can contain any combination of DeviceElements between the curly braces,
  but there are some required elements that every device definition must include, 
  see DeviceElement rule.

DeviceElement ::= Attr | Pin | Info
 -----
 A Device can contain any combination of attribute declarations, pin declarations, or 
  info statements, but there are 3 required attributes which every device definition 
  must include:
   1. REFPREFIX: The value of REFPREFIX is a STRING that will be used as a prefix by the
    compiler when automatically generating unique reference designators for each device 
    instantiation. (This is done if the reference designator is not explicitly set using
    the REFDES attribute).
   2. FOOTPRINT: The value of FOOTPRINT is the name of the footprint (or package) in 
    your chosen layout tool that can be used to identify the device being declared. 
    This value can then be used by the back-end tools when generating your netlist.
   3. LIBRARY: The value of LIBRARY is the name of the library in your layout tool that
    contains the footprint mentioned above. This value can then be used by the back-end 
    tools when generating your netlist.
   By convention, these attributes are upper-case, but that is not required and they are
    not case sensitive.

Attr ::= "attr" AttrName "=" STRING ";"
 -----
 Attributes can be used to contain any type of data desired with reference to
  a specific device. 
 AttrName is an identifier used to refer to the attribute from other rules 
  in the grammar, see Identifier section below.
 There has been some discussion about whether VALUE or Value should be the same or 
  different attributes and whether the user should be warned. The current tools give a 
  warning and then treat them as a single attribute.
 There are some optional special attributes:
  REFDES: If the REFDES attribute is defined as anything other than an empty string, 
   the compiler will use the value of REFDES as the device instantiation's unique 
   reference designator, rather than generating one using REFPREFIX.
  PINCOUNT: The value of the PINCOUNT attribute must be an Integer. If the number of
   pins declared in the device doesn't match the value of PINCOUNT, the compiler should
   through an error. 
 Other common uses for attributes:
  VALUE: used to define resistance, capacitance, inductance
  COST: can be used for bill of materials and part procurement
  MFGR: can be used for bill of materials and part procurement
  PARTNUMBER: can be used for bill of materials and part procurement
  etc.
 Essentially, attributes can be used to store any data necessary for back-end tools to use.

Pin ::= PinType [Vector] PinName "=" "{" PhysicalPinName [( "," PhysicalPinName )*] "}" ";"
 -----
 The Pin rule is used to declare pins and to map logical PinNames to be 
  used when instantiating the device in a Design to the PhysicalPinName from the 
  footprint (or package) definition in your chosen layout tool.
 PinType is used to specify a specific pin type which can be used by an electric 
  rule checker once the entire design has been elaborated. See the PinType rule.
 PinName is an identifier used to refer to the pin declaration from other rules 
  in the grammar, see Identifier section below.
 A Vector of pins, or multi-bit pins with the same name can be declared using the 
  Vector rule, see section on Vectors and RANGES below.
 A PhysicalPinName is an identifier that can be used to reference the unique pin 
  or pad in your layout editor footprint (or package) definition.
 The curly braces contain a comma separated list of one or more PhysicalPinNames. 
  If the vector option is used, the vector indices on the left side of the equals 
  sign (reading from left to right), are mapped to  the PhysicalPinNames on the right 
  side of the equals sign(also reading from left to right).
 The number of pins enumerated on the right side of the equals sign should always 
  equal the number of PhysicalPinNames on the left side.

PinType ::= "pin"
                | "inpin"
                | "outpin"
                | "iopin"
                | "pwrpin"
                | "suppin"
                | "ocpin"
                | "oepin"
                | "tripin"
                | "passpin"
                | "ncpin"
 -----
 The PinType rule is a collection of keywords that can be used to define pins.
  The keywords stand for the following pin types:
   pin - Unspecified Pin
   inpin - Input Pin
   outpin - Output Pin
   iopin - IO Pin
   pwrpin - Power Pin
   suppin - Supply Pin
   ocpin - Open Collector Pin
   oepin - Open Emitter Pin
   tripin - Tri-State Pin
   passpin - Passive Pin
   ncpin - No Connection
  These pintypes can be used by an electric rule checker to find faulty 
   connections within a net.
 

Info ::= "info" "{" STRING "}"
 -----
 Info statements can be used to make comments (such as placement needs) 
  about a specific device or connection which can then be relayed to the 
  layout designer. 


//////////////
// Designs  //
//////////////

Design ::=      ( "design" DesignName "{" DesignElement* "}" )
                |  ( "subdesign" SubDesignName "{" SubDesignElement* "}" )
 -----
 The Design rule encompasses both design declarations and sub-design declarations.
 DesignName and SubDesignName are identifiers used to reference Design/SubDesign 
  declarations from other rules in the grammar, see Identifier section below.
 Designs are the top level declaration for a PHDLDesign, and can contain any combination
  of DesignElements or SubDesignElements respectively.

DesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info
 -----
 Designs can contain any combination of nets, instances, info statements, and connection assignments.

SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info | PortDeclaration
 -----
 Sub-designs can contain everything that a design can, plus PortDeclarations.


/////////////////
// Connections //
/////////////////

NetDeclaration ::= "net" [Vector] NetName ( "," NetName )* ( "{" NetElement* "}" ) | ";"
 -----
 The NetDeclaration rule is used to declare any number of nets of the same width.
 NetName is an Identifier used to reference each individual net within other rules in the
  grammar, see Identifier section below.
 A Vector can be used to declare multi-bit nets, see Vector and Range rules below.
 Each NetDeclaration contains a comma-separated-list of 1 or more NetNames to be declared,
  and ends with either a semicolon or a combination of NetElements within curly braces.
 NetElements defined in a NetDeclaration will be applied to all nets declared in the 
  declaration.
                
NetElement ::= Attr | Info
 -----
 NetDeclarations can contain attribute declarations or info statements.

PortDeclaration ::= "port" [Vector] PortName ( "," PortName )* ( "{" Info* "}" ) | ";"
 -----
 The PortDeclaration rule is the same as a NetDeclaration, except that attributes are not
  allowed to be defined for Ports.
 PortDeclarations are only allowed within sub-designs and are used with hierarchy in-order 
  to connect internal nets or pins to the outside world. 
 Ports can also be used as nets/connections to establish connectivity between pins within a
  sub-design. When a design is elaborated by the compiler, the design must be "flattened"
  in-order to generate output data. In the case where a port is declared as "open", this
  connectivity within the sub-design must not be destroyed, even though there is connection 
  made outside the sub-design itself.
 

/////////////////////
// Instances       //
/////////////////////

Instance ::= ( ("inst" InstName "of" QualifiedDeviceName "{" InstanceElement* "}" ) 
					| ("inst" Array InstName "of" QualifiedDeviceName "{" ArrayInstanceElement* "}" ) )
             | ( ( "subinst" SubInstName "of" QualifiedSubDesignName [STRING] "{" SubInstElement* "}" )
                    | ( "subinst" Array SubInstName "of" QualifiedSubDesignName [STRING] "{" ArraySubInstElement* "}" ) )
 -----
 The Instance rule is used to instantiate devices or sub-designs.
 InstName and SubInstName are Identifiers used to reference insts or subinsts from other
  rules within the grammar, see Identifier section below.
 QualifiedDeviceName and QualifiedSubDesignName are references to Devices or Sub-Designs
  defined/declared elsewhere in the user's source code.
 Multiple devices can be instanced at once using the Array rule below. If this is the case,
  certain InstanceElements may allow a qualifier in-order to specify which instantiated 
  device(s) is/are being referenced. (See the ArrayInstanceElement rule below).
 Multiple sub-designs can be instanced at once using the Array rule below. If this is the case,
  certain SubInstElements may allow a qualifier in-order to specify which instantiated 
  sub-design(s) is/are being referenced. (See the ArraySubInstElement rule below).
 The optional STRING field in sub-instance declarations is a REFPREFIX value that will be 
  prepended to the reference designators of all devices instantiated within the sub-design 
  instantiation.
  
 
QualifiedDeviceName ::= [PackageName "."] DeviceName              
 -----
 The QualifiedDeviceName rule allows for devices to be referenced by package, if
  the specified device is contained within a package and has not already been 
  imported using the Import rule.
 
InstanceElement ::= Attr | RefAttr | PinAssign | Info
 -----
 Instances can have any combination of attribute declarations, attribute references,
  pin assignments, and info statements. However each device instance is required to 
  have a pin assignment for every pin declared within the referenced device definition.

ArrayInstanceElement ::= Attr | QualifiedRefAttr | QualifiedPinAssign | Info
 -----
 If multiple devices are instantiated using the Array rule, attribute references and 
  pin assignments are allowed to use an optional qualifier to specify the device 
  instantiations being referenced. (See QualifiedRefAttr, QualifierPinAssign, and 
  Qualifier rules).

QualifiedSubDesignName ::= [PackageName "."] SubDesignName
 -----
 The QualifiedSubDeviceName rule allows for devices to be referenced by package, if
  the specified sub-design is contained within a package and has not already been 
  imported using the Import rule.
  
SubInstElement ::= Attr | SubAttr | PortAssign | Info
 -----
 SubInstances can have any combination of attribute declarations, sub-attribute references,
  port assignments, and info statements. However each sub-design instance is required to 
  have a port assignment for every port declared within the referenced sub-design.
 
ArraySubInstElement ::= Attr | QualifiedSubAttr | QualifiedPortAssign | Info
 -----
 If multiple sub-designs are instantiated using the Array rule, sub-attribute references and 
  port assignments are allowed to use an optional qualifier to specify the sub-design 
  instantiations being referenced. (See QualifiedSubAttr, QualifierPortAssign, and 
  Qualifier rules).
  
/////////////////////
// Ref Attributes  //
/////////////////////

QualifiedRefAttr ::= [Qualifier] RefAttr
 -----
 
RefAttr ::= AttrName "=" STRING ";"
 -----
  // This is when you refer to and modify an existing attribute on a
  // device.  That is, you can over-ride the attribute value
  // specifiecd when the device was declared.
  // In constrast, the Attr rule allows you to create a new attribute
  // (either in a device decl or when instancing).



///TODO - Check - Qualified should only be allowed for arrays

/////////////////////
// Pin Assignments //
/////////////////////

QualfiedPinAssign ::= ( "combine" "(" QualifiedPinReference ")" "=" Concatenation ";" )
					| ( QualifiedPinReference "=" Concatenation ";" )
 -----
 					
PinAssign ::= ( "combine" "(" PinReference ")" "=" Concatenation ";" )
			| ( PinReference "=" Concatenation ";" )
 -----
 
QualifiedPinReference ::= [Qualifier] PinName [Slices]
 -----
 
PinReference ::= PinName [Slices]
 -----
 

/////////////////////
// Sub Attributes  //
/////////////////////

QualifiedSubAttr ::= [Qualifier] SubAttr
 -----
 
SubAttr ::= [RefTail] InstName "." AttrName "=" STRING ";"
 -----
  // This is how you reach down into the hierarchy (arbitrarily deep)
  // and change an attribute value on an instance

RefTail ::= SubInstName "." [RefTail]
 -----

//////////////////////
// Port Assignments //
//////////////////////

QualifiedPortAssign ::= ( "combine" "(" QualifiedPortReference ")" "=" Concatenation ";" )
					| ( QualifiedPortReference "=" Concatenation ";" )
 -----
 					
PortAssign ::= ( "combine" "(" PortReference ")" "=" Concatenation ";" )
			| ( PortReference "=" Concatenation ";" )
 -----
 
QualifiedPortReference ::= [Qualifier] PortName [Slices]
 -----
 
PortReference ::= PortName [Slices]
 -----

////////////////////////////
// Connection Assignments //
////////////////////////////

//Connections are either Ports or Nets

ConnectionAssign ::= ConnectionName [Slices] "=" Concatenation ";"
 -----
  //The scope of allowable ConnectionNames includes only the connections 
  //  declared within the current design or subdesign

Concatenation ::=       ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
                        ( ConnectionRef ( "&" ConnectionRef )* ) |
                        ( "<" ConnectionRef ">" ) |
                        ( ConnectionRef "*" ) |
                        ( "open" )
 -----
  // A concatenation can take a number of forms:
  // {a, b, c} or a & b & c which are similar to Verilog's - the signals are lined up left-to-right to make a bus
  // <a> or a* which make as many copies of the signal as needed for the LHS of the assignment statement
  // "open" means that the pin or port is purposely being left unconnected

ConnectionRef ::= ConnectionName [Slices]
 -----
 
ConnectionName ::= NetName | PortName
 -----
 

//////////////////////////////////////////
// Indices, Slices, Vectors, and Arrays //
//////////////////////////////////////////

Indices ::= "(" (   Range  | ( INT ( "," INT )* )  ) ")"
 -----
  // Round braces are used for arrays of things (instances or subdesigns)

Slices ::= "[" (   Range  | ( INT ( "," INT )* )  ) "]"
 -----
  // Square braces are used for multi-bit things

Vector ::= "[" Range "]"
 -----
 
Array ::= "(" Range ")"
 -----
 
Range ::= INT ":" INT
 -----
  // Ranges for arrays, vectors, slices, and indices can be either
  // ascending or descending.  They imply a left-to-right ordering.

///////////////////////////////////
// Qualifier and Qualified Names //
///////////////////////////////////

Qualifier ::= "this" [Indices] "."
 -----
QualifiedNameOptWildCard ::= PackageName "." ( "*" | ( DeviceName | DesignName | SubDesignName ) )
 -----
 
/////////////////////////////////
// Element Names/Identifiers   //
/////////////////////////////////
DeviceName ::= PhdlID
PinName ::= PhdlID
PhysicalPinName ::= PhdlID
NetName ::= PhdlID
PortName ::= PhdlID
PackageName:: = Identifier
AttrName ::= Identifier
DesignName ::= Identifier
SubDesignName ::= Identifier
InstName ::= Identifier
SubInstName ::= Identifier


PhdlID ::= Integer | Identifier | PINUM

Lexical Elements
----------------

PHDL files must always consist of valid UTF-8 encoded Unicode text. This input
is then normalized and split into lexical elements used in the rest of the
grammar. Each element is described in detail below.

Identifiers
~~~~~~~~~~~

All identifiers are like standard Unicode identifiers, but are additionally
allowed to start with connectors such as underscore.

------------
Identifier = (\p{ID_Start} | \p{Pc}) \p{ID_Continue}*
------------

Integers
~~~~~~~~

All integers are in decimal. Leading zeros are explicitly allowed.

------------
Integer = [0-9]+
------------

Pin Numbers
~~~~~~~~~~~

PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+

Strings
~~~~~~~

STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
        "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"

Comments
~~~~~~~~

PHDL allows C\+\+-style single line and multi-line comments. Single-line
comments start with +//+ and ends at any Unicode line-ending sequence.

Multi-line comments start with +/\*+ and end with +*/+.

Neither kind of comments can be nested in any way.

----------------
Line_Ending =
 | \x0A       // LINE FEED (LF)
 | \x0B       // LINE TABULATION
 | \x0C       // FORM FEED (FF)
 | \x0D       // CARRIAGE RETURN (CR)
 | \x85       // NEXT LINE (NEL)
 | \x2028     // LINE SEPARATOR
 | \x2029     // PARAGRAPH SEPARATOR
Single_Line_Comment = "//" (!Line_Ending)* Line_Ending
Multi_Line_Comment = "/*" !("*/") "*/"
----------------

Whitespace
~~~~~~~~~~

All whitespace characters between (but not part of) individual lexical elements
are ignored. Whitespace consists of one or more Unicode characters in a row
with the "Pattern_White_Space" property.

---------------
Whitespace = \p{Pattern_White_Space}+
---------------
