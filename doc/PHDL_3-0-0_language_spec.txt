PHDL Language Grammar Specification
===================================
Version 3.0.0, Unreleased

The following specification includes two main parts:
	1. The Grammar or Allowable Syntax
	2. Explanations of each of the specified rules detailing the 
		significance of each grammar rule and its parts and what each 
		token/rule represents.


Parser Rules
------------

PHDLDesign ::= Import* ( Package | Device | Design )*
 -----
 PHDLDesign is the head rule for the source code model generated by the
  parser. 
 A PHDLDesign may contain any combination of package declarations, device
  definitions or design declarations, in any order, but the compiler must 
  require declare-before-use. 
 All imports must come before any package, device, or design declarations/
  definitions.

Import ::= "import" QualifiedNameOptWildCard ";"
 -----
 Imports can be used at the beginning of a .phdl file in order to import
  packages, devices, sub-designs that have been previously defined
  in other files, to be used in the current file.
 There is an optional wild card, that can be used to import the contents of
  an entire package. 
 The devices, designs, and sub-designs must be referenced according to their
  specified package name, see QualifiedNameOptWildCard rule below.

Package ::= "package" PackageName "{" Import* ( Device | Design )* "}"
 -----
 Packages can be used to organized groups of device definitions and sub-design
  declarations into a package for later use.
 PackageName is an identifier used to refer to the package in other rules in the 
  grammar, see Identifier section below.
 A package contains the device definitions and design declarations contained within
  the curly braces. Any combination or order of device definitions and design 
  declarations are allowed.
 Imports can also be used to import definitions or declarations from external files 
  to be included within the current package, but imports must come before any other 
  definitions/declarations.

//////////////
// Devices  //
//////////////

Device ::= "device" DeviceName "{" DeviceElement* "}"
 -----

DeviceElement ::= Attr | Pin | Info
 -----

Attr ::= "attr" AttrName "=" STRING ";"
 -----
  // The AttrName and value associated with an attribute is strictly
  // user-defined.  However, there are some required attributes
  // including: REFPREFIX, FOOTPRINT, and LIBRARY.  By convention,
  // they are upper case but that is not required and they are not
  // case sensitive.  There has been some discussion about whether
  // VALUE and Value should be the same or different attributes and
  // whether the user should be warned.  The current tools give a
  // warning and then combine them.

Pin ::= PinType [Vector] PinName "=" "{" PhysicalPinName [( "," PhysicalPinName )*] "}" ";"
 -----
  // Pins can be single bits wide or can be vectors of multiple bits.
  // The values in { } are the physical pin names presumably taken
  // from the footprint in the library..

PinType ::= "pin"
                | "inpin"
                | "outpin"
                | "iopin"
                | "pwrpin"
                | "suppin"
                | "ocpin"
                | "oepin"
                | "tripin"
                | "passpin"
                | "ncpin"
 -----
  // The purpose of the pin directions is to allow for ERC where it
  // checks for multiple outpins on a net, for example.  To date, all
  // designs have just used "pin" but an ERC has been implemented in
  // the 2.1 tools.

Info ::= "info" "{" STRING "}"
 -----
  // The purpose of info is to allow the designer to attach
  // information to specific devices, nets, ports, designs/subdesigns,
  // and instances/subinstances.  This gets propagated to the output
  // files and can be used to communicate with the layout engineer.


//////////////
// Designs  //
//////////////

Design ::=      ( "design" DesignName "{" DesignElement* "}" )
                |  ( "subdesign" SubDesignName "{" SubDesignElement* "}" )
 -----
  // This rule encompasses both design declarations and subdesign declarations

DesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info
 -----
  // Designs can contain nets, instances, info statements, and
  // net-to-net assignments.

SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | Info | PortDeclaration
 -----
  // Subdesigns can contain everything designs can plus port declarations.


/////////////////
// Connections //
/////////////////

NetDeclaration ::= "net" [Vector] NetName ( "," NetName )* ( "{" NetElement* "}" ) | ";"
 -----
  // Net declarations can be multiple bits wide.  Multiple names in one
  // declaration are all of that type. 
                
NetElement ::= Attr | Info
 -----
  // If desired, attributes or info
  // can be attached to the nets as in:
  // net a, b, c { info { "These adsfgkjadsfljkas df" }}

PortDeclaration ::= "port" [Vector] PortName ( "," PortName )* ( "{" Info* "}" ) | ";"
 -----
  // These are similar to net declarations but bring out signals for subdesigns

/////////////////////
// Instances       //
/////////////////////

Instance ::= ( ("inst" InstName "of" QualifiedDeviceName "{" InstanceElement* "}" ) 
					| ("inst" Array InstName "of" QualifiedDeviceName "{" ArrayInstanceElement* "}" ) )
             | ( ( "subinst" SubInstName "of" QualifiedSubDesignName [STRING] "{" SubInstElement* "}" )
                    | ( "subinst" Array SubInstName "of" QualifiedSubDesignName [STRING] "{" ArraySubInstElement* "}" ) )
 -----
 
QualifiedDeviceName ::= [PackageName "."] DeviceName              
 -----
 
InstanceElement ::= Attr | RefAttr | PinAssign | Info
 -----

ArrayInstanceElement ::= Attr | QualifiedRefAttr | QualifiedPinAssign | Info
 -----

QualifiedSubDesignName ::= [PackageName "."] SubDesignName
 -----
 
SubInstElement ::= Attr | SubAttr | PortAssign | Info
 -----
 
ArraySubInstElement ::= Attr | QualifiedSubAttr | QualifiedPortAssign | Info
 -----

/////////////////////
// Ref Attributes  //
/////////////////////

QualifiedRefAttr ::= [Qualifier] RefAttr
 -----
 
RefAttr ::= AttrName "=" STRING ";"
 -----
  // This is when you refer to and modify an existing attribute on a
  // device.  That is, you can over-ride the attribute value
  // specifiecd when the device was declared.
  // In constrast, the Attr rule allows you to create a new attribute
  // (either in a device decl or when instancing).



///TODO - Check - Qualified should only be allowed for arrays

/////////////////////
// Pin Assignments //
/////////////////////

QualfiedPinAssign ::= ( "combine" "(" QualifiedPinReference ")" "=" Concatenation ";" )
					| ( QualifiedPinReference "=" Concatenation ";" )
 -----
 					
PinAssign ::= ( "combine" "(" PinReference ")" "=" Concatenation ";" )
			| ( PinReference "=" Concatenation ";" )
 -----
 
QualifiedPinReference ::= [Qualifier] PinName [Slices]
 -----
 
PinReference ::= PinName [Slices]
 -----
 

/////////////////////
// Sub Attributes  //
/////////////////////

QualifiedSubAttr ::= [Qualifier] SubAttr
 -----
 
SubAttr ::= [RefTail] InstName "." AttrName "=" STRING ";"
 -----
  // This is how you reach down into the hierarchy (arbitrarily deep)
  // and change an attribute value on an instance

RefTail ::= SubInstName "." [RefTail]
 -----

//////////////////////
// Port Assignments //
//////////////////////

QualifiedPortAssign ::= ( "combine" "(" QualifiedPortReference ")" "=" Concatenation ";" )
					| ( QualifiedPortReference "=" Concatenation ";" )
 -----
 					
PortAssign ::= ( "combine" "(" PortReference ")" "=" Concatenation ";" )
			| ( PortReference "=" Concatenation ";" )
 -----
 
QualifiedPortReference ::= [Qualifier] PortName [Slices]
 -----
 
PortReference ::= PortName [Slices]
 -----

////////////////////////////
// Connection Assignments //
////////////////////////////

//Connections are either Ports or Nets

ConnectionAssign ::= ConnectionName [Slices] "=" Concatenation ";"
 -----
  //The scope of allowable ConnectionNames includes only the connections 
  //  declared within the current design or subdesign

Concatenation ::=       ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
                        ( ConnectionRef ( "&" ConnectionRef )* ) |
                        ( "<" ConnectionRef ">" ) |
                        ( ConnectionRef "*" ) |
                        ( "open" )
 -----
  // A concatenation can take a number of forms:
  // {a, b, c} or a & b & c which are similar to Verilog's - the signals are lined up left-to-right to make a bus
  // <a> or a* which make as many copies of the signal as needed for the LHS of the assignment statement
  // "open" means that the pin or port is purposely being left unconnected

ConnectionRef ::= ConnectionName [Slices]
 -----
 
ConnectionName ::= NetName | PortName
 -----
 

//////////////////////////////////////////
// Indices, Slices, Vectors, and Arrays //
//////////////////////////////////////////

Indices ::= "(" (   Range  | ( INT ( "," INT )* )  ) ")"
 -----
  // Round braces are used for arrays of things (instances or subdesigns)

Slices ::= "[" (   Range  | ( INT ( "," INT )* )  ) "]"
 -----
  // Square braces are used for multi-bit things

Vector ::= "[" Range "]"
 -----
 
Array ::= "(" Range ")"
 -----
 
Range ::= INT ":" INT
 -----
  // Ranges for arrays, vectors, slices, and indices can be either
  // ascending or descending.  They imply a left-to-right ordering.

///////////////////////////////////
// Qualifier and Qualified Names //
///////////////////////////////////

Qualifier ::= "this" [Indices] "."
 -----
QualifiedNameOptWildCard ::= PackageName "." ( "*" | ( DeviceName | DesignName | SubDesignName ) )
 -----
 
/////////////////////////////////
// Element Names/Identifiers   //
/////////////////////////////////
DeviceName ::= PhdlID
PinName ::= PhdlID
PhysicalPinName ::= PhdlID
NetName ::= PhdlID
PortName ::= PhdlID
PackageName:: = Identifier
AttrName ::= Identifier
DesignName ::= Identifier
SubDesignName ::= Identifier
InstName ::= Identifier
SubInstName ::= Identifier


PhdlID ::= Integer | Identifier | PINUM

Lexical Elements
----------------

PHDL files must always consist of valid UTF-8 encoded Unicode text. This input
is then normalized and split into lexical elements used in the rest of the
grammar. Each element is described in detail below.

Identifiers
~~~~~~~~~~~

All identifiers are like standard Unicode identifiers, but are additionally
allowed to start with connectors such as underscore.

------------
Identifier = (\p{ID_Start} | \p{Pc}) \p{ID_Continue}*
------------

Integers
~~~~~~~~

All integers are in decimal. Leading zeros are explicitly allowed.

------------
Integer = [0-9]+
------------

Pin Numbers
~~~~~~~~~~~

PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+

Strings
~~~~~~~

STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
        "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"

Comments
~~~~~~~~

PHDL allows C\+\+-style single line and multi-line comments. Single-line
comments start with +//+ and ends at any Unicode line-ending sequence.

Multi-line comments start with +/\*+ and end with +*/+.

Neither kind of comments can be nested in any way.

----------------
Line_Ending =
 | \x0A       // LINE FEED (LF)
 | \x0B       // LINE TABULATION
 | \x0C       // FORM FEED (FF)
 | \x0D       // CARRIAGE RETURN (CR)
 | \x85       // NEXT LINE (NEL)
 | \x2028     // LINE SEPARATOR
 | \x2029     // PARAGRAPH SEPARATOR
Single_Line_Comment = "//" (!Line_Ending)* Line_Ending
Multi_Line_Comment = "/*" !("*/") "*/"
----------------

Whitespace
~~~~~~~~~~

All whitespace characters between (but not part of) individual lexical elements
are ignored. Whitespace consists of one or more Unicode characters in a row
with the "Pattern_White_Space" property.

---------------
Whitespace = \p{Pattern_White_Space}+
---------------
