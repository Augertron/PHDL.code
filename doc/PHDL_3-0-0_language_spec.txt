PHDL Language Grammar Specification
===================================
Version 3.0.0, Unreleased

The following specification includes two main parts:
	1. The Grammar or Allowable Syntax
	2. Explanations of each of the specified rules detailing the 
		significance of each grammar rule and its parts and what each 
		token/rule represents.

For a more detailed understanding of how the grammar should be interpreted, the tutorials at:
http://phdl.sourceforge.net/2.1/tutorial/rc_helloworld.php are a good resource. They were written
however with the 2.1 version of the grammar in mind.
We highly suggest you read through these tutorials as they go into depth about how the grammar 
should be implemented.


Parser Rules
------------

PHDLDesign ::= Import* ( Package | Device | Design )*
 -----
 PHDLDesign is the head rule for the source code model generated by the
  parser. 
 A PHDLDesign may contain any combination of package declarations, device
  definitions or design declarations, in any order, but the compiler must 
  require declare-before-use. 
 All imports must come before any package, device, or design declarations/
  definitions.

Import ::= "import" QualifiedNameOptWildCard ";"
 -----
 Imports can be used at the beginning of a .phdl file in order to import
  packages, devices, sub-designs that have been previously defined
  in other files, to be used in the current file.
 There is an optional wild card, that can be used to import the contents of
  an entire package. 
 The devices, designs, and sub-designs must be referenced according to their
  specified package name, see QualifiedNameOptWildCard rule below.

Package ::= "package" PackageName "{" Import* ( Device | Design )* "}"
 -----
 Packages can be used to organized groups of device definitions and sub-design
  declarations into a package for later use.
 PackageName is an identifier used to refer to the package from other rules in the 
  grammar, see Identifier section below.
 A package contains the device definitions and design declarations contained within
  the curly braces. Any combination or order of device definitions and design 
  declarations are allowed.
 Imports can also be used to import definitions or declarations from external files 
  to be included within the current package, but imports must come before any other 
  definitions/declarations.

//////////////
// Devices  //
//////////////

Device ::= "device" DeviceName "{" DeviceElement* "}"
 -----
 The Device rule is used to define the interface between a "PHDL device instantiation"
  and the footprint (or package) definition within your chosen layout tool. 
 DeviceName is an identifier used to refer to the device definition from other rules 
  in the grammar, see Identifier section below.
 Devices can contain any combination of DeviceElements between the curly braces,
  but there are some required elements that every device definition must include, 
  see DeviceElement rule.

DeviceElement ::= AttrDeclaration | PinDeclaration | InfoStatement
 -----
 A Device can contain any combination of attribute declarations, pin declarations, or 
  info statements, but there are 3 required attributes which every device definition 
  must include:
   1. REFPREFIX: The value of REFPREFIX is a STRING that will be used as a prefix by the
    compiler when automatically generating unique reference designators for each device 
    instantiation. (This is done if the reference designator is not explicitly set using
    the REFDES attribute).
   2. FOOTPRINT: The value of FOOTPRINT is the name of the footprint (or package) in 
    your chosen layout tool that can be used to identify the device being declared. 
    This value can then be used by the back-end tools when generating your netlist.
   3. LIBRARY: The value of LIBRARY is the name of the library in your layout tool that
    contains the footprint mentioned above. This value can then be used by the back-end 
    tools when generating your netlist.
   By convention, these attributes are upper-case, but that is not required and they are
    not case sensitive.

AttrDeclaration ::= "attr" AttrName "=" STRING ";"
 -----
 Attributes can be used to contain any type of data desired with reference to
  a specific device. 
 Attributes declarations are allowed within both device definitions and device 
  instantiations as well as in net declarations. 
 AttrName is an identifier used to refer to the attribute from other rules 
  in the grammar, see Identifier section below.
 There has been some discussion about whether VALUE or Value should be the same or 
  different attributes and whether the user should be warned. The current tools give a 
  warning and then treat them as a single attribute.
 There are some optional special attributes:
  REFDES: If the REFDES attribute is defined as anything other than an empty string, 
   the compiler will use the value of REFDES as the device instantiation's unique 
   reference designator, rather than generating one using REFPREFIX.
  PINCOUNT: The value of the PINCOUNT attribute must be an Integer. If the number of
   pins declared in the device doesn't match the value of PINCOUNT, the compiler should
   through an error. 
 Other common uses for attributes:
  VALUE: used to define resistance, capacitance, inductance
  COST: can be used for bill of materials and part procurement
  MFGR: can be used for bill of materials and part procurement
  PARTNUMBER: can be used for bill of materials and part procurement
  etc.
 Essentially, attributes can be used to store any data necessary for back-end tools to use.

PinDeclaration ::= PinType [Vector] PinName "=" "{" PhysicalPinName [( "," PhysicalPinName )*] "}" ";"
 -----
 The PinDeclaration rule is used to declare pins and to map logical PinNames to be 
  used when instantiating the device in a Design to the PhysicalPinName from the 
  footprint (or package) definition in your chosen layout tool.
 PinType is used to specify a specific pin type which can be used by an electric 
  rule checker once the entire design has been elaborated. See the PinType rule.
 PinName is an identifier used to refer to the pin declaration from other rules 
  in the grammar, see Identifier section below.
 A Vector of pins, or multi-bit pins with the same name can be declared using the 
  Vector rule, see section on Vectors and RANGES below.
 A PhysicalPinName is an identifier that can be used to reference the unique pin 
  or pad in your layout editor footprint (or package) definition.
 The curly braces contain a comma separated list of one or more PhysicalPinNames. 
  If the vector option is used, the vector indices on the left side of the equals 
  sign (reading from left to right), are mapped to  the PhysicalPinNames on the right 
  side of the equals sign(also reading from left to right).
 The number of pins enumerated on the right side of the equals sign should always 
  equal the number of PhysicalPinNames on the left side.

PinType ::= "pin"
                | "inpin"
                | "outpin"
                | "iopin"
                | "pwrpin"
                | "suppin"
                | "ocpin"
                | "oepin"
                | "tripin"
                | "passpin"
                | "ncpin"
 -----
 The PinType rule is a collection of keywords that can be used to define pins.
  The keywords stand for the following pin types:
   pin - Unspecified Pin
   inpin - Input Pin
   outpin - Output Pin
   iopin - IO Pin
   pwrpin - Power Pin
   suppin - Supply Pin
   ocpin - Open Collector Pin
   oepin - Open Emitter Pin
   tripin - Tri-State Pin
   passpin - Passive Pin
   ncpin - No Connection
  These pintypes can be used by an electric rule checker to find faulty 
   connections within a net.
 

InfoStatement ::= "info" "{" STRING "}"
 -----
 The InfoStatement rule can be used to make comments (such as placement needs) 
  about a specific device or connection which can then be relayed to the 
  layout designer. 


//////////////
// Designs  //
//////////////

Design ::=      ( "design" DesignName "{" DesignElement* "}" )
                |  ( "subdesign" SubDesignName "{" SubDesignElement* "}" )
 -----
 The Design rule encompasses both design declarations and sub-design declarations.
 DesignName and SubDesignName are identifiers used to reference Design/SubDesign 
  declarations from other rules in the grammar, see Identifier section below.
 Designs are the top level declaration for a PHDLDesign, and can contain any combination
  of DesignElements or SubDesignElements respectively.

DesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement
 -----
 Designs can contain any combination of nets, instances, info statements, and connection assignments.

SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement | PortDeclaration
 -----
 Sub-designs can contain everything that a design can, plus PortDeclarations.


/////////////////
// Connections //
/////////////////

NetDeclaration ::= "net" [Vector] NetName ( "," NetName )* ( "{" NetElement* "}" ) | ";"
 -----
 The NetDeclaration rule is used to declare any number of nets of the same width.
 NetName is an Identifier used to reference each individual net within other rules in the
  grammar, see Identifier section below.
 A Vector can be used to declare multi-bit nets, see Vector and Range rules below.
 Each NetDeclaration contains a comma-separated-list of 1 or more NetNames to be declared,
  and ends with either a semicolon or a combination of NetElements within curly braces.
 NetElements defined in a NetDeclaration will be applied to all nets declared in the 
  declaration.
                
NetElement ::= AttrDeclaration | InfoStatement
 -----
 NetDeclarations can contain attribute declarations or info statements.

PortDeclaration ::= "port" [Vector] PortName ( "," PortName )* ( "{" InfoStatement* "}" ) | ";"
 -----
 The PortDeclaration rule is the same as a NetDeclaration, except that attributes are not
  allowed to be defined for Ports.
 PortDeclarations are only allowed within sub-designs and are used with hierarchy in-order 
  to connect internal nets or pins to the outside world. 
 Ports can also be used as nets/connections to establish connectivity between pins within a
  sub-design. When a design is elaborated by the compiler, the design must be "flattened"
  in-order to generate output data. In the case where a port is declared as "open", this
  connectivity within the sub-design must not be destroyed, even though there is connection 
  made outside the sub-design itself.
 

/////////////////////
// Instances       //
/////////////////////

Instance ::= ( "inst" [Array] InstName "of" QualifiedDeviceName "{" InstanceElement* "}" ) 
             | ( "subinst" [Array] SubInstName "of" QualifiedSubDesignName [STRING] "{" SubInstElement* "}" )
 -----
 The Instance rule is used to instantiate devices or sub-designs.
 InstName and SubInstName are Identifiers used to reference insts or subinsts from other
  rules within the grammar, see Identifier section below.
 QualifiedDeviceName and QualifiedSubDesignName are references to Devices or Sub-Designs
  defined/declared elsewhere in the user's source code.
 Multiple devices can be instanced at once using the Array rule below. 
 The optional STRING field in sub-instance declarations is a REFPREFIX value that will be 
  prepended to the reference designators of all devices instantiated within the sub-design 
  instantiation.
  
 
QualifiedDeviceName ::= [PackageName "."] DeviceName              
 -----
 The QualifiedDeviceName rule allows for devices to be referenced by package, if
  the specified device is contained within a package and has not already been 
  imported using the Import rule.
 
InstanceElement ::= AttrDeclaration | RefAttr | PinAssign | InfoStatement
 -----
 Instances can have any combination of attribute declarations, attribute references,
  pin assignments, and info statements. However each device instance is required to 
  have a pin assignment for every pin declared within the referenced device definition.

QualifiedSubDesignName ::= [PackageName "."] SubDesignName
 -----
 The QualifiedSubDeviceName rule allows for devices to be referenced by package, if
  the specified sub-design is contained within a package and has not already been 
  imported using the Import rule.
  
SubInstElement ::= AttrDeclaration | SubAttr | PortAssign | InfoStatement
 -----
 SubInstances can have any combination of attribute declarations, sub-attribute references,
  port assignments, and info statements. However each sub-design instance is required to 
  have a port assignment for every port declared within the referenced sub-design.
  
/////////////////////
// Ref Attributes  //
/////////////////////
  
RefAttr ::= [Qualifier] AttrName "=" STRING ";"
 -----
 The RefAttr rule is used to modify an existing attribute when instantiating a device.
  In other words, it allows you to over-ride the attribute value specified when the 
  device was defined.
 AttrName is an identifier used to reference the already defined attribute.
 STRING is the new value for the attribute.
 The optional Qualifier rule should only be allowed in the case where an array of devices are
  being instanced at once.

/////////////////////
// Pin Assignments //
/////////////////////
    		
PinAssign ::= ( "combine" "(" PinReference ")" "=" Concatenation ";" )
					| ( PinReference "=" Concatenation ";" )
 -----
 The PinAssign rule is used to assign pins within a device instantiation to existing 
  connections (nets or ports) or to assign them as "open".
 There must be a pin assignment assigning every pin declared in the device 
  definition referenced by the device definition.
 PinReferences allow slices, which allow a user to assign multiple bits to a net at once. 
 The order of assignment in PHDL always takes place from left-to-right in the order the 
  arrayed object was declared. The following pin assignment is given as an example:
  
  //Device Library (required attributes omitted)
  device hdr2 {
  	pin[1:0] p = {p1, p2};
  }
  
  design top {
    net[3:2] bus;
  	inst myHdr of hdr2 {
  		p = bus;
  	}
  }
 
 In the above case, the pin p[1] is assigned to the net bus[3] and the pin p[0] is assigned
  to the net bus[2].
 
 The compiler should throw an error if the pin width on the left of the assignment does not
  match the pin width on the right side.
 Within an arrayed device instance, the optional combine notation can be used. The combine notation
  should be illegal in the case where a single device is being instanced.
  (See section on combine notation below.)
  
PinReference ::= [Qualifier] PinName [Slices]
 ----- 
 The PinReference rule is a reference to set of pins that are to be assigned connection.
 The optional Qualifier rule should only be allowed when an array of devices are being instanced
  at once. 
 PinName is the identifier used to reference the PinDeclaration of the pins to be assigned 
  connections. The PinDeclaration should have been previously declared in the device definition 
  currently being instanced.
 The optional Slices rule allows for referencing of specific bits within a multi-bit vector of
  pins. This can either be done with a Range or by comma separated list of indices.
 Assignments using Slices should always be done reading from left-to-right. (See Slices rule).
 If the Slices rule is not used on a multi-bit vector of pins, the QualifiedPinReference refers
  to the entire vector of pins and they should be assigned from left-to-right in the order they
  were declared in the device definition.  
  
 Combine Notation
 ~~~~~~~~~~~~~~~~
 Combine notation takes an array of pins that are common across an instance array and lines
  them up into a larger array. The order of assignment in PHDL always takes place from left-to-right
  in the order the arrayed object was declared. The example below shows this:
  
 device memory_1024x8 {
 	//Attributes omitted
 	pin[7:0] data;       //Our memory has an 8 bit wide data pin array
 	//...
 }
 
 design myDesign {
 	net[15:0] data_bus;  //We have a 16 bit data bus
 	
 	inst(1:0) memory_array of memory_1024x8 {
 		combine(data) = data_bus;   //Using combine we can line up the two 8bit pin arrays
 									//from both memory devices into a 16bit pin array and 
 									//then connect them to a 16bit bus.
 									//this(1).data[7:0] is now assigned to data_bus[15:8] and
 									//this(0).data[7:0] is now assigned to data_bus[7:0]
 	}
 }
 
 If the combine notation is not used the pins are connected in parallel. For example the 
  combine statement above could have been replaced with the following: 
 
 data = data_bus;  
 
  and the data_bus net declaration replaced with:
  
 net[7:0] data_bus;
 
 Thus, the data_bus would necessarily be only 8 bits wide and both 8 bit data arrays would be 
  connected to it. (this(1).data[7:0] would be assigned to data_bus[7:0] and this(0).data[7:0] 
  would also be assigned to data_bus[7:0])
 
 The compiler should throw an error if the pin width on the left of the assignment does not
  match the pin width on the right side.

/////////////////////
// Sub Attributes  //
/////////////////////

SubAttr ::= [Qualifier] [RefTail] InstName "." AttrName "=" STRING ";"
 -----
 The optional Qualifier rule should only be allowed within an array of sub-designs are 
  being instanced at once.
  // This is how you reach down into the hierarchy (arbitrarily deep)
  // and change an attribute value on an instance

RefTail ::= SubInstName "." [RefTail]
 -----

//////////////////////
// Port Assignments //
//////////////////////
			
PortAssign ::= ( "combine" "(" PortReference ")" "=" Concatenation ";" )
			| ( PortReference "=" Concatenation ";" )
 -----
 
PortReference ::= [Qualifier] PortName [Slices]
 -----
 The optional Qualifier rule should only be allowed within an array of sub-designs are 
  being instanced at once.

////////////////////////////
// Connection Assignments //
////////////////////////////

//Connections are either Ports or Nets

ConnectionAssign ::= ConnectionName [Slices] "=" Concatenation ";"
 -----
  //The scope of allowable ConnectionNames includes only the connections 
  //  declared within the current design or subdesign

Concatenation ::=       ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
                        ( ConnectionRef ( "&" ConnectionRef )* ) |
                        ( "<" ConnectionRef ">" ) |
                        ( ConnectionRef "*" ) |
                        ( "open" )
 -----
  // A concatenation can take a number of forms:
  // {a, b, c} or a & b & c which are similar to Verilog's - the signals are lined up left-to-right to make a bus
  // <a> or a* which make as many copies of the signal as needed for the LHS of the assignment statement
  // "open" means that the pin or port is purposely being left unconnected

ConnectionRef ::= ConnectionName [Slices]
 -----
 
ConnectionName ::= NetName | PortName
 -----
 

//////////////////////////////////////////
// Indices, Slices, Vectors, and Arrays //
//////////////////////////////////////////

Indices ::= "(" (   Range  | ( INT ( "," INT )* )  ) ")"
 -----
  // Round braces are used for arrays of things (instances or subdesigns)

Slices ::= "[" (   Range  | ( INT ( "," INT )* )  ) "]"
 -----
  // Square braces are used for multi-bit things

Vector ::= "[" Range "]"
 -----
 
Array ::= "(" Range ")"
 -----
 
Range ::= INT ":" INT
 -----
  // Ranges for arrays, vectors, slices, and indices can be either
  // ascending or descending.  They imply a left-to-right ordering.

///////////////////////////////////
// Qualifier and Qualified Names //
///////////////////////////////////

Qualifier ::= "this" [Indices] "."
 -----
QualifiedNameOptWildCard ::= PackageName "." ( "*" | ( DeviceName | DesignName | SubDesignName ) )
 -----
 
/////////////////////////////////
// Element Names/Identifiers   //
/////////////////////////////////
DeviceName ::= PhdlID
PinName ::= PhdlID
PhysicalPinName ::= PhdlID
NetName ::= PhdlID
PortName ::= PhdlID
PackageName:: = Identifier
AttrName ::= Identifier
DesignName ::= Identifier
SubDesignName ::= Identifier
InstName ::= Identifier
SubInstName ::= Identifier


PhdlID ::= Integer | Identifier | PINUM

Lexical Elements
----------------

PHDL files must always consist of valid UTF-8 encoded Unicode text. This input
is then normalized and split into lexical elements used in the rest of the
grammar. Each element is described in detail below.

Identifiers
~~~~~~~~~~~

All identifiers are like standard Unicode identifiers, but are additionally
allowed to start with connectors such as underscore.

------------
Identifier = (\p{ID_Start} | \p{Pc}) \p{ID_Continue}*
------------

Integers
~~~~~~~~

All integers are in decimal. Leading zeros are explicitly allowed.

------------
Integer = [0-9]+
------------

Pin Numbers
~~~~~~~~~~~

PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+

Strings
~~~~~~~

STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
        "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"

Comments
~~~~~~~~

PHDL allows C\+\+-style single line and multi-line comments. Single-line
comments start with +//+ and ends at any Unicode line-ending sequence.

Multi-line comments start with +/\*+ and end with +*/+.

Neither kind of comments can be nested in any way.

----------------
Line_Ending =
 | \x0A       // LINE FEED (LF)
 | \x0B       // LINE TABULATION
 | \x0C       // FORM FEED (FF)
 | \x0D       // CARRIAGE RETURN (CR)
 | \x85       // NEXT LINE (NEL)
 | \x2028     // LINE SEPARATOR
 | \x2029     // PARAGRAPH SEPARATOR
Single_Line_Comment = "//" (!Line_Ending)* Line_Ending
Multi_Line_Comment = "/*" !("*/") "*/"
----------------

Whitespace
~~~~~~~~~~

All whitespace characters between (but not part of) individual lexical elements
are ignored. Whitespace consists of one or more Unicode characters in a row
with the "Pattern_White_Space" property.

---------------
Whitespace = \p{Pattern_White_Space}+
---------------
