PHDL Language Grammar Specification
===================================
Version 3.0.0, Unreleased

The following specification includes two main parts:
	1. The Grammar or Allowable Syntax
	2. Explanations of each of the specified rules detailing the 
		significance of each grammar rule and its parts and what each 
		token/rule represents.

For an example of how the grammar should be interpreted, the tutorials at:
http://phdl.sourceforge.net/2.1/tutorial/rc_helloworld.php are a good resource. They were written
however with the 2.1 version of the grammar in mind.

Parser Rules
------------

PHDLRoot ::= Import* ( Package | Device | Design )*
 -----
 	PHDLRoot is the head rule for the source code model generated by the
 parser. 
 	A PHDLRoot may contain any combination of package declarations, device
 definitions or design declarations, in any order, but the compiler must 
 require declare-before-use. 
 	All imports must come before any package, device, or design declarations/
 definitions.

Import ::= "import" QualifiedNameOptWildCard ";"
 -----
 	Imports can be used at the beginning of a .phdl file in order to import
 packages, devices, sub-designs that have been previously defined
 in other files, to be used in the current file.
 	There is an optional wild card, that can be used to import the contents of
 an entire package. 
 	The devices, designs, and sub-designs must be referenced according to their
 specified package name, see QualifiedNameOptWildCard rule below.

Package ::= "package" PackageName "{" Import* ( Device | Design )* "}"
 -----
 	Packages can be used to organized groups of device definitions and sub-design
 declarations into a package for later use.
 	PackageName is an identifier used to refer to the package from other rules in the 
 grammar, see Identifier section below.
 	A package contains the device definitions and design declarations contained within
 the curly braces. Any combination or order of device definitions and design 
 declarations are allowed.
 	Imports can also be used to import definitions or declarations from external files 
 to be included within the current package, but imports must come before any other 
 definitions/declarations.

Devices
~~~~~~~

Device ::= "device" DeviceName "{" DeviceElement* "}"
 -----
 	The Device rule is used to define the interface between a "PHDL device instantiation"
 and the footprint (or package) definition within your chosen layout tool. 
 	DeviceName is an identifier used to refer to the device definition from other rules 
 in the grammar, see Identifier section below.
 	Devices can contain any combination of DeviceElements between the curly braces,
 but there are some required elements that every device definition must include, 
 see DeviceElement rule.

DeviceElement ::= AttrDeclaration | PinDeclaration | InfoStatement
 -----
 	A Device can contain any combination of attribute declarations, pin declarations, or 
 info statements, but there are 3 required attribute declarations which every device definition 
 must include:
   1. REFPREFIX: The value of REFPREFIX is a STRING that is a prefix used by the
    compiler when automatically generating unique reference designators for each device 
    instantiation. (This is done if the reference designator is not explicitly set using
    the REFDES attribute).
   2. FOOTPRINT: The value of FOOTPRINT is the name of the footprint (or package) in 
    your chosen layout tool that can be used to identify the device being declared. 
    This value can then be used by the back-end tools when generating your netlist.
   3. LIBRARY: The value of LIBRARY is the name of the library in your layout tool that
    contains the footprint mentioned above. This value can then be used by the back-end 
    tools when generating your netlist.
   
 	By convention, these attributes are upper-case, but that is not required and they are
 not case sensitive.

AttrDeclaration ::= "attr" AttrName "=" STRING ";"
 -----
 	Attributes can be used to contain any type of data desired with reference to
 a specific device. 
 	Attributes declarations are allowed within both device definitions and device 
 instantiations as well as in net declarations. 
 	AttrName is an identifier used to refer to the attribute from other rules 
 in the grammar, see Identifier section below.
 	There has been some discussion about whether VALUE or Value should be the same or 
 different attributes and whether the user should be warned. The current tools give a 
 warning and then treat them as a single attribute.
 	There are some optional special attributes:
	  REFDES: If the REFDES attribute is defined as anything other than an empty string, 
	   the compiler will use the value of REFDES as the device instantiation's unique 
	   reference designator, rather than generating one using REFPREFIX.
	  PINCOUNT: The value of the PINCOUNT attribute must be an Integer. If the number of
	   pins declared in the device doesn't match the value of PINCOUNT, the compiler should
	   throw an error. 
	 Other common uses for attributes:
	  VALUE: used to define resistance, capacitance, inductance
	  COST: can be used for bill of materials and part procurement
	  MFGR: can be used for bill of materials and part procurement
	  PARTNUMBER: can be used for bill of materials and part procurement
	  etc.
 	Essentially, attributes can be used to store any data necessary for back-end tools to use.

PinDeclaration ::= PinType [Vector] PinName "=" "{" PhysicalPinName [( "," PhysicalPinName )*] "}" ";"
 -----
 	The PinDeclaration rule is used to declare pins and to map logical PHDL PinNames to be 
 used when instantiating the device in a Design to the PhysicalPinName from the 
 footprint (or package) definition in your chosen layout tool.
 	PinType is used to specify a specific pin type which can be used by an electric 
 rule checker once the entire design has been elaborated. See the PinType rule.
 	PinName is an identifier used to refer to the pin declaration from other rules 
 in the grammar, see Identifier section below.
 	A Vector of pins, or multi-bit pins with the same name can be declared using the 
 Vector rule, see section on Vectors and RANGES below.
 	A PhysicalPinName is an identifier that can be used to reference the unique pin 
 or pad in your layout editor footprint (or package) definition.
 	The curly braces contain a comma separated list of one or more PhysicalPinNames. 
 	If the vector option is used, the vector indices on the left side of the equals 
 sign (reading from left to right), are mapped to  the PhysicalPinNames on the right 
 side of the equals sign(also reading from left to right).
 	The number of pins enumerated on the right side of the equals sign should always 
 equal the number of PhysicalPinNames on the left side.
 	For more information on how PinDeclarations should be interpreted, see the section
 entitled: "Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, 
 PinDeclarations, and Assignments".

PinType ::= "pin"
                | "inpin"
                | "outpin"
                | "iopin"
                | "pwrpin"
                | "suppin"
                | "ocpin"
                | "oepin"
                | "tripin"
                | "passpin"
                | "ncpin"
 -----
 	The PinType rule is a collection of keywords that can be used to define pins.
  	The keywords stand for the following pin types:
	   pin - Unspecified Pin
	   inpin - Input Pin
	   outpin - Output Pin
	   iopin - IO Pin
	   pwrpin - Power Pin
	   suppin - Supply Pin
	   ocpin - Open Collector Pin
	   oepin - Open Emitter Pin
	   tripin - Tri-State Pin
	   passpin - Passive Pin
	   ncpin - No Connection
  	These pintypes can be used by an electric rule checker to find faulty 
  connections within a net.
 

InfoStatement ::= "info" "{" STRING "}"
 -----
 	The InfoStatement rule can be used to make comments (such as placement needs) 
 about a specific device or connection which can then be relayed to the 
 layout designer. 

Designs
~~~~~~~

Design ::=      ( "design" DesignName "{" DesignElement* "}" )
                |  ( "subdesign" SubDesignName "{" SubDesignElement* "}" )
 -----
 	The Design rule encompasses both design declarations and sub-design declarations.
 	
 	A Design encompasses all the connectivity of a single PCB. No connectivity extends outside the scope 
 of the Design block. In other words they are the top level of a phdl design.
	When the front-end of the compiler elaborates, or flattens the hierarchy of the design and 
 walks the design graph in order to determine connectivity through out the entire  design, it 
 should use the Design rule as the root node. 
 	DesignName and SubDesignName are identifiers used to reference Design/SubDesign 
 declarations from other rules in the grammar, see Identifier section below.
 	Designs can contain any combination of DesignElements.
 
 	Sub-Designs were specifically created to enable the use of hierarchy and are virtually 
 identical to designs with the added ability to declare ports, thus allowing the user to define 
 a hierarchical block of connectivity and instantiations, which can then be instantiated itself 
 in an upper level of design or even replicated throughout the design. 
 	Sub-Designs are invalid if they do not contain at least one device or sub-design instantiation. 

DesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement
 -----
 	Designs can contain any combination of nets, instances, info statements, and connection assignments.

SubDesignElement ::= NetDeclaration | Instance | ConnectionAssign | InfoStatement | PortDeclaration
 -----
 	Sub-designs can contain everything that a design can, plus PortDeclarations.


Connections
~~~~~~~~~~~
Both nets and ports are Connections.

NetDeclaration ::= "net" [Vector] NetName ( "," NetName )* ( "{" NetElement* "}" ) | ";"
 -----
 	The NetDeclaration rule is used to declare any number of nets of the same width.
 	NetName is an Identifier used to reference each individual net within other rules in the
 grammar, see Identifier section below.
 	A Vector can be used to declare multi-bit nets, see Vector and Range rules below.
 	Each NetDeclaration contains a comma-separated-list of 1 or more NetNames to be declared,
 and ends with either a semicolon or a combination of NetElements within curly braces.
 	NetElements defined in a NetDeclaration will be applied to all nets declared in the 
 declaration.
 	Each NetName enumerated in a NetDeclaration represents an individual net that must be treated
 individually and separately from all other nets declared with in the NetDeclaration. In other 
 words, once a net has been declared it has no relation or connection to any other net declared 
 within the same NetDeclaration, besides that it was declared with the same width and at the same 
 time.
                
NetElement ::= AttrDeclaration | InfoStatement
 -----
 NetDeclarations can contain attribute declarations or info statements.

PortDeclaration ::= "port" [Vector] PortName ( "," PortName )* ( "{" InfoStatement* "}" ) | ";"
 -----
 	The PortDeclaration rule is the same as a NetDeclaration, except that attributes are not
 allowed to be defined for Ports.
 	PortDeclarations are only allowed within sub-designs and are used with hierarchy in-order 
 to connect internal nets or pins to the outside world. 
 	Each PortName enumerated in a NetDeclaration represents an individual net that must be treated
 individually and separately from all other nets declared with in the PortDeclaration. In other 
 words, once a net has been declared it has no relation or connection to any other net declared 
 within the same PortDeclaration, besides that it was declared with the same width and at the same 
 time.
 	Ports can also be used as nets/connections to establish connectivity between pins within a
 sub-design. When a design is elaborated by the compiler, the design must be "flattened"
 in-order to generate output data. In the case where a port is declared as "open", this
 connectivity within the sub-design must not be destroyed, even though there is connection 
 made outside the sub-design itself.
 


Instances
~~~~~~~~~

Instance ::= ( "inst" [Array] InstName "of" QualifiedDeviceName "{" InstanceElement* "}" ) 
             | ( "subinst" [Array] SubInstName "of" QualifiedSubDesignName [STRING] "{" SubInstElement* "}" )
 -----
 	The Instance rule is used to instantiate devices or sub-designs.
 	InstName and SubInstName are Identifiers used to reference insts or subinsts from other
 rules within the grammar, see Identifier section below.
 	QualifiedDeviceName and QualifiedSubDesignName are references to Devices or Sub-Designs
 defined/declared elsewhere in the user's source code.
 	Multiple devices can be instanced at once using the Array rule below. When this occurs,
 each individual instance in the array is interpreted as its own individual instance. It does
 not inherently have any connection to any of the other devices in the array unless the designer 
 so specifies by connecting their pins to the same nets. The same applies to sub-design instances
 and their respective port-assignments. For more information on how Arrays should be interpreted, 
 see the section entitled: "Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, 
 PinDeclarations, and Assignments".
 	The optional STRING field in sub-instance declarations is a REFPREFIX value that will be 
 prepended to the reference designators of all devices instantiated within the sub-design 
 instantiation. Another option is to declare an attribute in the sub-instance called REFPREFIX. The 
 value of this attribute will then be prepended to all reference designators of all instances, 
 sub-instances and connections within the sub-instance. In either case the "/" character will be used
 as a delimiter between the REFPREFIX and the original reference designator.
 	Instancing a device in PHDL is equivalent to dragging a device from a library in a 
 conventional PCB design tool onto the schematic page. Instancing a device defines two 
 relationships: (1) which device the instance inherits all pins from, and (2) defines 
 how all of the pins are to be connected to the rest of the design. 
 	A similar concept applies when instantiating a sub-design except that it is equivalent 
 to adding a pre-defined hierarchical block to a design and connecting its ports to nets in the 
 current design.
 	It is important to remember when elaborating a hierarchical design that the design must be 
 flattened before connectivity may be determined. Each port of the sub-instance must be checked for 
 its connectivity with pins/nets/connections within the sub-design first and then second for possible 
 connectivity with nets/connections assigned to it through port assignments in the upper design.
  
 
QualifiedDeviceName ::= [PackageName "."] DeviceName              
 -----
 	The QualifiedDeviceName rule allows for devices to be referenced by package, if
 the specified device is contained within a package and has not already been 
 imported using the Import rule.
 	PackageName is thus the name of the package containing the specified device.
 
InstanceElement ::= AttrDeclaration | RefAttr | PinAssign | InfoStatement
 -----
 	Instances can have any combination of attribute declarations, attribute references,
 pin assignments, and info statements. However each device instance is required to 
 have a pin assignment for every pin declared within the referenced device definition.

QualifiedSubDesignName ::= [PackageName "."] SubDesignName
 -----
 	The QualifiedSubDeviceName rule allows for devices to be referenced by package, if
 the specified sub-design is contained within a package and has not already been 
 imported using the Import rule.
 	PackageName is thus the name of the package containing the specified sub-design.
  
SubInstElement ::= AttrDeclaration | SubAttrRef | PortAssign | InfoStatement
 -----
 	SubInstances can have any combination of attribute declarations, sub-attribute references,
 port assignments, and info statements. However each sub-design instance is required to 
 have a port assignment for every port declared within the referenced sub-design.
 	There is an optional special attribute which can be declared in the sub-instance called REFPREFIX. 
 The value of this attribute will then be prepended to all reference designators of all instances, 
 sub-instances, and connections within the sub-instance. In this case the "/" character will be used
 as a delimiter between the REFPREFIX and the original reference designator.
  

Ref Attributes
~~~~~~~~~~~~~~
  
RefAttr ::= [Qualifier] AttrName "=" STRING ";"
 -----
 	The RefAttr rule is used to modify an existing attribute when instantiating a device.
 	In other words, it allows you to over-ride the attribute value specified when the 
 device was defined.
 	AttrName is an identifier used to reference the already defined attribute.
 	STRING is the new value for the attribute.
 	The optional Qualifier rule should only be allowed in the case where an array of devices are
 being instanced at once.


Pin Assignments
~~~~~~~~~~~~~~~
    		
PinAssign ::= ( "combine" "(" PinReference ")" "=" Concatenation ";" )
					| ( PinReference "=" Concatenation ";" )
 -----
 	The PinAssign rule is used to assign pins within a device instantiation to existing 
 connections (nets or ports) or to assign them as "open".
 	There must be a pin assignment assigning every pin declared in the device 
 definition referenced by the device definition.
 	PinReferences allow slices, which allow a user to assign multiple bits to a net at once. 
 	The order of assignment in PHDL always takes place from left-to-right in the order the 
 arrayed object was declared. The following pin assignment is given as an example:
  
  //Device Library (required attributes omitted)
  device hdr2 {
  	pin[1:0] p = {p1, p2};
  }
  
  design top {
    net[3:2] bus;
  	inst myHdr of hdr2 {
  		p = bus;
  	}
  }
 
 	In the above case, the pin p[1] is assigned to the net bus[3] and the pin p[0] is assigned
 to the net bus[2].
 
	The compiler should throw an error if the number of pins referenced left of the assignment 
 does not match the number of connections referenced by the concatenation the right side.
 (Count each individual pin indice as a pin).
 	Within an arrayed device instance, the optional combine notation can be used. The combine notation
 should be illegal in the case where a single device is being instanced.
 (See section on combine notation below.)
  
PinReference ::= [Qualifier] PinName [Slices]
 ----- 
 	The PinReference rule is a reference to set of pins that are to be assigned connection.
 	The optional Qualifier rule should only be allowed when an array of devices are being instanced
 at once. 
 	PinName is the identifier used to reference the PinDeclaration of the pins to be assigned 
 connections. The PinDeclaration should have been previously declared in the device definition 
 currently being instanced.
 	The optional Slices rule allows for referencing of specific bits within a multi-bit vector of
 pins. This can either be done with a Range or by comma separated list of indices.
 	Assignments using Slices should always be done reading from left-to-right. (See Slices rule).
 	If the Slices rule is not used on a multi-bit vector of pins, the PinReference refers
 to the entire vector of pins and they should be assigned from left-to-right in the order they
 were declared in the device definition.  
  
Combine Notation
~~~~~~~~~~~~~~~~
 	Combine notation takes an array of pins that are common across an instance array and lines
 them up into a larger array. The order of assignment in PHDL always takes place from left-to-right
 in the order the arrayed object was declared. The example below shows this:
  
 device memory_1024x8 {
 	//Attributes omitted
 	pin[7:0] data;       //Our memory has an 8 bit wide data pin array
 	//...
 }
 
 design myDesign {
 	net[15:0] data_bus;  //We have a 16 bit data bus
 	
 	inst(1:0) memory_array of memory_1024x8 {
 		combine(data) = data_bus;   //Using combine we can line up the two 8bit pin arrays
 									//from both memory devices into a 16bit pin array and 
 									//then connect them to a 16bit bus.
 									//this(1).data[7:0] is now assigned to data_bus[15:8] and
 									//this(0).data[7:0] is now assigned to data_bus[7:0]
 	}
 }
 
 	If the combine notation is not used the pins are connected in parallel. For example the 
 combine statement above could have been replaced with the following: 
 
 data = data_bus;  
 
  and the data_bus net declaration replaced with:
  
 net[7:0] data_bus;
 
 	Thus, the data_bus would necessarily be only 8 bits wide and both 8 bit data arrays would be 
 connected to it. (this(1).data[7:0] would be assigned to data_bus[7:0] and this(0).data[7:0] 
 would also be assigned to data_bus[7:0])
 
 	The compiler should throw an error if the pin width on the left of the assignment does not
 match the pin width on the right side.


Sub Attribute References
~~~~~~~~~~~~~~~~~~~~~~~~

SubAttrRef ::= [Qualifier] [RefTail] InstName "." AttrName "=" STRING ";"
 -----
 	The SubAttrRef rule can be used within a sub-instance to reach down into the hierarchy
 and change an attribute value on an instance. This allows the user to define a hierarchical 
 block, instantiate it many times throughout their design, and then customize the individual 
 sub-instances. (For example: A design may contain multiple audio ports whose circuitry is 
 identical with the exception of an RC filter's resistance and capacitance values).
 	The optional RefTail rule can be used to reach down arbitrarily deep from sub-instance to 
 sub-instance to reach the instance who's attribute the user desires to change.
 	InstName is an identifier used to reference the instance who's attribute the user desires
 to change.
 	AttrName is an identifier used to reference the attribute who's value is to be changed.
 	STRING is the new value the attribute's prior value should be over written with.
 	The optional Qualifier rule should only be allowed within an array of sub-design instances.
 See the Qualifier rule below for more detail on what it allows.
 
RefTail ::= SubInstName [Indices] "." [RefTail]
 -----
 	The RefTail rule allows the user to reach arbitrarily deep into the hierarchy from
 sub-instance to sub-instance. 
 	The optional Indices rule allows the user to reference a set of arrayed sub-instances 
 somewhere down the hierarchy using either a range or a comma separated list of indices.
 	For more information on how Indices should be interpreted, see the section entitled: 
 "Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, PinDeclarations, 
 and Assignments" as well as the Indices and Range rules.


Port Assignments
~~~~~~~~~~~~~~~~
			
PortAssign ::= ( "combine" "(" PortReference ")" "=" Concatenation ";" )
			| ( PortReference "=" Concatenation ";" )
 -----
 	The PortAssign rule should be interpreted exactly as the PinAssign rule except that it 
 is used to assign ports in sub-design instances to connections in the current design rather than
 to assign pins. All the same specifications that apply to pin assignements should apply to 
 port assignments.
 	Within an arrayed sub-design instance, the optional combine notation can be used. The combine 
 notation should be illegal in the case where a single sub-design is being instanced.
 (See section on combine notation above.)

PortReference ::= [Qualifier] PortName [Slices]
 -----
 	A PortReference should be interpreted to be exactly like a PinReference except that it
 references PortDeclarations in the sub-design declaration being instanced, rather than
 PinDeclartations in the associated device definition.
 	The optional Qualifier rule should only be allowed within an array of sub-design instances.
 See the Qualifier rule below for more detail on what it allows. 


Connection Assignments and Concatenation
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ConnectionAssign ::= ConnectionName [Slices] "=" Concatenation ";"
 -----
 	The ConnectionAssign rule allows for conductivity to established between two connections.
 Such as between two nets or between a net and a port.   
 	ConnectionName is an identifier used to reference the port or net being assigned.
 	The scope of allowable ConnectionNames for a given ConnectionAssign should only include 
 the connections declared within the current design or sub-design.
 	The optional Slices rule allows for referencing of specific bits within a multi-bit vector
 connection. This can either be done with a Range or by comma separated list of indices.
 	See the Slices rule for more details.
 	When slices are used, assignment should always be done reading the indices on the left side
 of the equals sign (from left-to-right) and connecting them one by one to the connections 
 on the right side of the equals sign (also reading from left-to-right).
 	When slices are not used for a vector connection, it is assumed that the entire vector is 
 being referenced (again reading the indices from left-to-right how the connection was 
 declared).
 	If the number of referenced connections on the left side of the equals sign  does not 
 equal the number of connections referenced by the concatenation, The compiler should 
 throw an error. (Count each individual indice as a connection).
 

Concatenation ::=       ( "{" ConnectionRef  ( "," ConnectionRef )* "}" ) |
                        ( ConnectionRef ( "&" ConnectionRef )* ) |
                        ( "<" ConnectionRef ">" ) |
                        ( ConnectionRef "*" ) |
                        ( "open" )
 -----
	A Concatenation can be used to concatenate or line up several connections into a large vector
 and then assign them to another vector of connections or pins.
	A concatenation can take a number of forms:
	 - A comma-separated list of ConnectionRefs contained within curly brackets, should be read from 
	   left-to-right as individual one-bit connections and lined up into a large multi-bit vector of 
	   connections.
	 - A list separated by the '&' character should be treated exactly like the comma-separated list 
	   above.
	 - A single one-bit (non-vector) connection enclosed in angle brackets '<' '>' should be replicated 
	   or branched into however many connections are needed to match the left hand side of the assignment. 
	   In other-words, every pin or connection on the left hand side of the assignment should be connected 
	   to this singular net in parallel.
	 - A single one-bit (non-vector) connection followed by the '*' symbol should be treated the same as
	   the connection enclosed in angle brackets above.
	 - A connection can also be defined as "open". This would have no affect if performing a
	   connection assign, but if performing a pin assignment or port assignment it signifies that nothing 
	   should be connected to the pin or port. 
	   If this occurs within a PortAssign, it is important to make sure that if the port was used as a 
	   connection between nets or pins down-within the sub-design that this connection is preserved when 
	   the design is elaborated.

ConnectionRef ::= ConnectionName [Slices]
 -----
 	A ConnectionRef is a reference to a ConnectionName with the option of using the 
 Slices rule to reference specific bits of a multi-bit vector connection. 
 	For more information on how Slices should be interpreted, see the section entitled: 
 "Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, PinDeclarations, 
 and Assignments" as well as the Slices and Range rules.
 	As always indices should be read from left-to-right.  
  
ConnectionName ::= NetName | PortName
 -----
 	ConnectionName is a substitute for either a NetName or a PortName.
 	PortNames should only be allowed however, if inside a sub-design.
 


Arrays, Indices, Vectors, and Slices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Array ::= "(" Range ")"
 -----
 	Arrays can be used to instantiate multiple devices or sub-designs with
 one instance declaration. This allows the user to instance an arbitrary
 number of similar devices or sub-designs and connect their pins/ports as 
 a unit rather than one by one. 
 	The Range for an array is enclosed in round braces to differentiate it 
 from the Vector rule. 

Indices ::= "(" (   Range  | ( Integer ( "," Integer )* )  ) ")"
 -----
 	The Indices rule can be used to reference a set of instanced devices or 
 sub-designs from an array, by index. 
 	This can either be done using a Range or with a comma-separated list of 
 indices. In both cases, the indices referenced must have been originally declared
 in the corresponding arrayed instance declaration.
 	The Indices rule is enclosed in round braces in-order to match
 Arrayed device or sub-design instantiations and to differentiate it from
 Slices.
 	Indices should only be allowed to be used when referencing an Array of device
 or sub-design instances.
  
Vector ::= "[" Range "]"
 -----
 	Vectors can be used to declare multi-bit pins, nets, or ports. This allows
 the user to declare and assign an arbitrary number of connections or pins 
 with the same name and all at once. Rather than individually. For example 
 the user could define a 16bit data pin for a memory chip, and then connect 
 it to a 16bit bus with only one line of code to define the pin and one line 
 to connect it when the device is instantiated.
 	The Range for a vector is enclosed in square brackets to differentiate it from
 the Array rule.
  
Slices ::= "[" (   Range  | ( Integer ( "," Integer )* )  ) "]"
 -----
 	The Slices rule can be used to reference a set of pins or connections declared
 as part of a vector, by index.
 	This can either be done using a Range or with a comma-separated list of 
 indices. In both cases, the indices referenced must have been originally declared
 in the corresponding vectored pin/connection declaration.
 	The Slices rule is enclosed in square brackets braces in-order to match
 Vector pin/connection declarations and to differentiate it from the Indices rule.
 	Slices should only be allowed to be used when referencing a Vector or 
 multi-bit pin or connection (port/net). 

 
Range ::= Integer ":" Integer
 -----
 	Ranges can be used to specify an ordered range of indices. The ':' character
 can be likened to the "downto" or "to" keywords in VHDL.
 	Both the Integers are included in the range.
 	For example the range: 7:0 specifies 8 individual indices from left-to-right 7 down to 0.
 	Ordering the other direction is also legal: 0:7 specifies 8 individual indices from 
 left-to-right 0 up to 7.
 
 	Another way to think of it is that the Range 1:3 means the following: reference 1,2,3 
 in that order and the Range 3:0 means the following: reference 3,2,1,0 in that order.
  
Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, PinDeclarations, and Assignments
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	It is important that each of these rules are interpreted and understood correctly 
 in all implementations of the language and whenever the language is used if correct
 output is to be generated. 
  
 There are a few rules that must be followed when interpreting these rules in-order
 to ensure this:
  1.  When interpreting arrayed device or sub-design instance declarations each instance 
      in the array must be interpreted and treated as its own unique individual instance. 
      The only difference between how this instance and a non-arrayed instance should be 
      handled is that it shares a name with the other instances in the array and can be 
      referenced by index.
      A unique identifier for this instance can be generated by concatenating the name 
      to its unique index.
  2.  When interpreting multi-bit or vectored connections/pins each connection/pin in the 
      vector must be interpreted and treated as its own unique individual connection/pin.
      The only difference between how this connection/pin and a non vectored connection/pin 
      is that it can shares a name with the other connections/pins in the vector and can be
      referenced by index.
      As arrayed device, a unique identifier for this connection/pin can be created by
      concatenating the name to its unique index.
  3.  Arrays, Indices, Vectors, Slices, Ranges, and Concatenations must be interpreted as a
      string of individual connections/pins/references lined up from left-to-right.
  4.  Lastly when interpreting assignments and pin declarations the left-most index referenced
      on the left hand side of the equal sign is to be assigned to the left-most index on the 
      right hand side of the equal sign (or the left-most PhysicalPinName on the right hand side 
      in the case of pin declarations). The second-left-most index referenced on the left hand 
      side of the assignment should be assigned to the second-left-most index on the right hand 
      side of the equals, etc...
      The number of references on both sides of the assignment should always be equal or the 
      compiler should throw an error.
      

Qualifier and Qualified Names
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Qualifier ::= "this" [Indices] "."
 -----
	 The Qualifier rule is used to specify a specific subset of an arrayed set of either 
 device or sub-design instances. 
	 The optional Indices rule is what allows specific instances within the array to be 
 referenced.
 	The Qualifier rule should only be allowed when wanting to reference a specific set of 
 either device or sub-design instances within an arrayed instance declaration. It specifies 
 a specific or a set of specific instances within the array to be referenced, allowing the 
 user to make a pin/port assignment or attribute reference specific to only certain instances 
 with in the array, referenced by index. This allows for many devices/sub-designs of the same 
 type to be instanced at once while connecting them differently as needed. The combine notation,
 allows for them to be connected together as a group with a single line of code, if so 
 desired as well.
 	For more information on how Indices should be interpreted, see the section entitled: 
 "Interpreting Arrays, Indices, Vectors, Slices, Ranges, Concatenations, PinDeclarations, 
 and Assignments" as well as the Indices and Range rules.
 
QualifiedNameOptWildCard ::= PackageName "." ( "*" | ( DeviceName | DesignName | SubDesignName ) )
 -----
 	The QualifiedNameOptWildCard rule allows for imports by package.
 	PackageName is a reference to a predefined package with devices, designs, or sub-designs that 
 the user desires to use within the current design. 
 	If the '*' character is used, all devices, designs, and sub-designs contained in the package 
 should be imported. If this is not the case only the specified device, design, or sub-design
 should be imported.
 

Element Names/Identifiers
~~~~~~~~~~~~~~~~~~~~~~~~~
DeviceName ::= PhdlID
PinName ::= PhdlID
PhysicalPinName ::= PhdlID
NetName ::= PhdlID
PortName ::= PhdlID
PackageName:: = Identifier
AttrName ::= Identifier
DesignName ::= Identifier
SubDesignName ::= Identifier
InstName ::= Identifier
SubInstName ::= Identifier


PhdlID ::= Integer | Identifier | PINUM
 -----
 	The PhdlID rule is currently used as a combination of the Integer, Identifier, and 
 PINNUM rules thus allowing the identifier to be any of these. 

Lexical Elements
----------------

PHDL files must always consist of valid UTF-8 encoded Unicode text. This input
is then normalized and split into lexical elements used in the rest of the
grammar. Each element is described in detail below.

Identifiers
~~~~~~~~~~~

All identifiers are like standard Unicode identifiers, but are additionally
allowed to start with connectors such as underscore.

------------
Identifier = (\p{ID_Start} | \p{Pc}) \p{ID_Continue}*
------------

Integers
~~~~~~~~

All integers are in decimal. Leading zeros are explicitly allowed.

------------
Integer = [0-9]+
------------

Pin Numbers
~~~~~~~~~~~

PINNUM: ('0'..'9'|'a'..'z'|'A'..'Z'|'_'|'+'|'-'|'$'|'/'|'@'|'!')+

Strings
~~~~~~~

STRING: '"' ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|'"' ) )* '"' |
        "'" ( '\\' ( 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' ) | !( '\\'|"'" ) )* "'"

Comments
~~~~~~~~

PHDL allows C\+\+-style single line and multi-line comments. Single-line
comments start with +//+ and ends at any Unicode line-ending sequence.

Multi-line comments start with +/\*+ and end with +*/+.

Neither kind of comments can be nested in any way.

----------------
Line_Ending =
 | \x0A       // LINE FEED (LF)
 | \x0B       // LINE TABULATION
 | \x0C       // FORM FEED (FF)
 | \x0D       // CARRIAGE RETURN (CR)
 | \x85       // NEXT LINE (NEL)
 | \x2028     // LINE SEPARATOR
 | \x2029     // PARAGRAPH SEPARATOR
Single_Line_Comment = "//" (!Line_Ending)* Line_Ending
Multi_Line_Comment = "/*" !("*/") "*/"
----------------

Whitespace
~~~~~~~~~~

All whitespace characters between (but not part of) individual lexical elements
are ignored. Whitespace consists of one or more Unicode characters in a row
with the "Pattern_White_Space" property.

---------------
Whitespace = \p{Pattern_White_Space}+
---------------
